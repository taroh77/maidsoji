; ======================================================================================
; ゲームのメインループ
; ======================================================================================

*main_game
	; 表示
	redraw 0			; 画面クリア
	gosub *gdraw 		; スプライト以外の描画
	gosub *spplot		; スプライトの表示位置計算
	gosub *sppos		; スプライトの位置反映
	es_draw				; スプライト描画
	redraw 1			; 画面の更新
	; 表示以外の処理
	await 1000/16		; 時間待ち(1/60秒)

	TIMES = TIMES +1
	game_info(GAME_INFO_RESTTIME) -= 1
	if game_info(GAME_INFO_RESTTIME) <= 0 {
		goto *end_stage	; 残り時間を過ぎたら試合終了
	}

	getreq record(0,timeindex),SYSREQ_TIMER
	gosub *checkinput 	; 入力キー確認
	getreq record(1,timeindex),SYSREQ_TIMER
	gosub *comthink 	; 主人公以外の行動の決定
	getreq record(2,timeindex),SYSREQ_TIMER
	gosub *execact		; 行動の処理
	getreq record(3,timeindex),SYSREQ_TIMER
	gosub *execbullet	; 弾丸の処理
	getreq record(4,timeindex),SYSREQ_TIMER
	gosub *culcbucket	; 色蓄積の計算
	getreq record(5,timeindex),SYSREQ_TIMER
	gosub *execstate	; ステートの処理
	getreq record(6,timeindex),SYSREQ_TIMER
	gosub *execbuff		; バフの処理
	getreq record(7,timeindex),SYSREQ_TIMER
	gosub *execdamage	; キャラへのダメージ処理
	getreq record(8,timeindex),SYSREQ_TIMER
	gosub *execheal		; 自然回復などの処理
	getreq record(9,timeindex),SYSREQ_TIMER
	
	; 処理時間の計算
	for i,0,10-1
		rangetime(i,timeindex) = record(i+1,timeindex) - record(i,timeindex)
	next

	if DEBUG_MODE : logmes strf("D TIMES=%d rangetime=%d,%d,%d,%d,%d,%d,%d",TIMES,rangetime(0,timeindex),rangetime(1,timeindex),rangetime(2,timeindex),rangetime(3,timeindex),rangetime(4,timeindex),rangetime(5,timeindex),rangetime(6,timeindex))

	timeindex = 1

	goto *main_game

; ======================================================================================
; 試合終了の処理
; ======================================================================================

; 残り時間を過ぎたら試合終了
*end_stage
	
	; 処理時間のロギング
	for i,0,9-1
		if DEBUG_MODE : logmes strf("D %s: 初期=%3d, 末期=%3d",rangetitle(i),rangetime(i,0),rangetime(i,1) )
	next
	
	if map_bucket_sum(0) > map_bucket_sum(1) { ; 勝った場合は次のステージへ
		game_info(GAME_INFO_NEXTSTAGE) += 1
		; 得点の計算
		base_score = 2 + game_info(GAME_INFO_TOTALLEVEL)
		if base_score < 1 : base_score = 1
		score = ( map_bucket_sum(0) - map_bucket_sum(1) ) * base_score
		score += game_info(GAME_INFO_STAGE) * 1000
		if game_info(GAME_INFO_TOTALLEVEL) < 0{
			score = score / ( game_info(GAME_INFO_TOTALLEVEL) * -1 + 1 )
		}
		if game_info(GAME_INFO_RETRY) > 0 {
			score = score / ( game_info(GAME_INFO_RETRY) +1 )
		}
		game_info(GAME_INFO_CURRSCORE) = score
		game_info(GAME_INFO_SCORE) += score
		
		mmplay sound_def_mediabuffid(SOUND_DEF_WIN)		; 勝利の効果音
	}
	else {
		game_info(GAME_INFO_CURRSCORE) = 0
		mmplay sound_def_mediabuffid(SOUND_DEF_LOSE)	; 敗北の効果音
	}
	mmstop
	mmplay music_def_mediabuffid(MUSIC_DEF_RESULT)	; リザルト画面の音楽

	goto *main_stageend
	

; ======================================================================================
; ゲームのメインループのサブルーチン
; ======================================================================================


; スプライト以外の描画
*gdraw
	font "",12
	color 0,0,0: boxf  ; 全画面塗りつぶし
	color 255,255,255

	if DEBUG_MODE = 1 {
		pos 245,470 : mes strf("TIMES: %5d",TIMES )	; ゲーム内時間（デバッグ用）
	}

	pos 130,350 : mes "ステージ"
	pos 145,362 : mes strf("%2d",game_info(GAME_INFO_STAGE) )
	
	pos 130,380 : mes "残り時間"
	pos 130,392 : mes strf("%5d",game_info(GAME_INFO_RESTTIME) )

	; mapの枠線
	color 64,64,64
	for i,0,11
		line 0,i*32,320,i*32
		line i*32,0,i*32,320
	next

	; 色蓄積情報の反映
	color 255,255,255
	for x,0,MAP_REAL_X
		for y,0,MAP_REAL_Y
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TYPE) = MAP_TYPE_NORMAL {
				; 塗りつぶしで表示
				maxt = map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y)
				if map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y) >= 0 {
					maxt = map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y)
					bright = map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,maxt) ; 色蓄積100でチームカラーを80%のRGBで表現
					color team_info(maxt,COLOR_R)*bright/125,team_info(maxt,COLOR_G)*bright/125,team_info(maxt,COLOR_B)*bright/125
					;color 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100, 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100, 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100
					boxf x*32+2, y*32+2, x*32+30, y*32+30
				}
			}
			if DEBUG_MODE = 1 {
				; 数値で表示
				; チーム0（自チーム）
				pos x*32, y*32
				color team_info(0,COLOR_R),team_info(0,COLOR_G),team_info(0,COLOR_B)
				mes map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)
				; チーム1
				pos x*32+16, y*32+20
				color team_info(1,COLOR_R),team_info(1,COLOR_G),team_info(1,COLOR_B)
				mes strf("%3d", map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,1))

				; デバッグ用
				pos x*32+16, y*32
				color 128,64,64
				mes strf("%3d", map_steps(MAP_MERGIN+x,MAP_MERGIN+y))
				pos x*32   , y*32+20
				color 64,64,64
				mes strf("%3d", map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y))
			}
		next
	next

	for x,0,MAP_REAL_X
		for y,0,MAP_REAL_Y
			; 侵入不可マスの表示
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TYPE) = MAP_TYPE_IMPOSSIBLE {
				color 192,0,0
				line x*32+2,y*32+2,x*32+30,y*32+30
				line x*32+30,y*32+2,x*32+2,y*32+30
			}
			; チームの拠点の表示
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TEAMBASE) >= 0 {
				t = map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TEAMBASE)
				;if DEBUG_MODE : logmes "D x,y,t="+x+","+y+","+t
				color team_info(t,COLOR_R),team_info(t,COLOR_G),team_info(t,COLOR_B)
				boxf x*32+10, y*32+10, x*32+22, y*32+22
			}
		next
	next
	

	; キャラ情報
	color 255,255,255

	; 主人公
	es_pos char_spid(0,CHAR_SPID_STATUS), 5,330 ; アイコン
	color 255,255,255
	pos 40,330
	mes char_desc(0,0) ; 名前
	mes strf("HP: %3d / %3d",char_info(0,CHAR_INFO_HP) ,char_info(0,CHAR_INFO_MAXHP_B) ) ; HP
	color 192,0,0
	boxf 40,354,40+80,357 ; 最大HP
	barlength = char_info(0,CHAR_INFO_HP) * 80 / char_info(0,CHAR_INFO_MAXHP_B)
	color 0,192,0
	boxf 40,354,40+barlength,357 ; 現在HP
	
	color 255,255,255
	pos 40,360
	mes strf("WP: %3d / %3d",char_info(0,CHAR_INFO_WP) ,char_info(0,CHAR_INFO_MAXWP_B) ) ; WP
	color 128,128,128
	boxf 40,372,40+80,375 ; 最大WP
	barlength = char_info(0,CHAR_INFO_WP) * 80 / char_info(0,CHAR_INFO_MAXWP_B)
	color 64,64,192
	boxf 40,372,40+barlength,375 ; 現在WP
	
	; 武器の状態
	color 255,255,255
	pos  40,382 : mes "z"
	pos  70,382 : mes "x"
	pos 100,382 : mes "c"
	
	color 64,64,64
	boxf  40,382, 40+20,385 ; 武器1
	boxf  70,382, 70+20,385 ; 武器2
	boxf 100,382,100+20,385 ; 武器3

	if char_info(0,CHAR_INFO_WEAPON1) >= 0 {
		perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON1),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON1HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON1),WEAPON_INFO_COOLDOWN)
		if perc < 0 : perc = 0
		if perc > 20 : perc = 20
		if perc = 20 {
			color 64,64,255
		} else {
			color 128,128,224
		}
		boxf  40,382, 40+perc,385 ; 武器1
	}
	
	if char_info(0,CHAR_INFO_WEAPON2) >= 0 {
		perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON2),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON2HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON2),WEAPON_INFO_COOLDOWN)
		if perc < 0 : perc = 0
		if perc > 20 : perc = 20
		if perc = 20 {
			color 64,64,255
		} else {
			color 128,128,224
		}
		boxf  70,382, 70+perc,385 ; 武器2
	}
	
	if char_info(0,CHAR_INFO_WEAPON3) >= 0 {
		perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON3),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON3HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON3),WEAPON_INFO_COOLDOWN)
		if perc < 0 : perc = 0
		if perc > 20 : perc = 20
		if perc = 20 {
			color 64,64,255
		} else {
			color 128,128,224
		}
		boxf 100,382,100+perc,385 ; 武器3
	}
	
	; 敵キャラ
	if char_info(1,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(1,CHAR_SPID_STATUS), 180,330 ; アイコン
		color 255,255,255
		pos 215,330
		mes char_desc(1,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(1,CHAR_INFO_HP) ,char_info(1,CHAR_INFO_MAXHP_B) ) ; HP
		color 192,0,0
		boxf 215,354,215+80,357 ; 最大HP
		barlength = char_info(1,CHAR_INFO_HP) * 80 / char_info(1,CHAR_INFO_MAXHP_B)
		color 0,192,0
		boxf 215,354,215+barlength,357 ; 現在HP
	
		color 255,255,255
		pos 215,360 
		mes strf("WP: %3d / %3d",char_info(1,CHAR_INFO_WP) ,char_info(1,CHAR_INFO_MAXWP_B) ) ; WP
		color 128,128,128
		boxf 215,372,215+80,375 ; 最大WP
		barlength = char_info(1,CHAR_INFO_WP) * 80 / char_info(1,CHAR_INFO_MAXWP_B)
		color 64,64,192
		boxf 215,372,215+barlength,375 ; 現在WP
	}
	if char_info(2,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(2,CHAR_SPID_STATUS), 180,380 ; アイコン
		color 255,255,255
		pos 215,380
		mes char_desc(2,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(2,CHAR_INFO_HP) ,char_info(2,CHAR_INFO_MAXHP_B) ) ; HP
		color 192,0,0
		boxf 215,404,215+80,407 ; 最大HP
		barlength = char_info(2,CHAR_INFO_HP) * 80 / char_info(2,CHAR_INFO_MAXHP_B)
		color 0,192,0
		boxf 215,404,215+barlength,407 ; 現在HP
	
		color 255,255,255
		pos 215,410 
		mes strf("WP: %3d / %3d",char_info(2,CHAR_INFO_WP) ,char_info(2,CHAR_INFO_MAXWP_B) ) ; WP
		color 128,128,128
		boxf 215,422,215+80,425 ; 最大WP
		barlength = char_info(2,CHAR_INFO_WP) * 80 / char_info(2,CHAR_INFO_MAXWP_B)
		color 64,64,192
		boxf 215,422,215+barlength,425 ; 現在WP
	}
	if char_info(3,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(3,CHAR_SPID_STATUS), 180,430 ; アイコン
		color 255,255,255
		pos 215,430
		mes char_desc(3,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(3,CHAR_INFO_HP) ,char_info(3,CHAR_INFO_MAXHP_B) ) ; HP
		color 192,0,0
		boxf 215,454,215+80,457 ; 最大HP
		barlength = char_info(3,CHAR_INFO_HP) * 80 / char_info(3,CHAR_INFO_MAXHP_B)
		color 0,192,0
		boxf 215,454,215+barlength,457 ; 現在HP
	
		color 255,255,255
		pos 215,460 
		mes strf("WP: %3d / %3d",char_info(3,CHAR_INFO_WP) ,char_info(3,CHAR_INFO_MAXWP_B) ) ; WP
		color 128,128,128
		boxf 215,472,215+80,475 ; 最大WP
		barlength = char_info(3,CHAR_INFO_WP) * 80 / char_info(3,CHAR_INFO_MAXWP_B)
		color 64,64,192
		boxf 215,472,215+barlength,475 ; 現在WP
	}

	; キャラの残りステート時間
	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue
		if char_info(i,CHAR_INFO_DOWN) = 1 : _continue
		if char_info(i,CHAR_INFO_STATE_DISPLAYED) = STATE_TYPE_NONE : _continue
		color 128,128,128
		boxf char_sppos(i,CIE_X)+6,char_sppos(i,CIE_Y)-3,char_sppos(i,CIE_X)+26,char_sppos(i,CIE_Y)
		color 224,64,16
		barlength = char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+char_info(i,CHAR_INFO_STATE_DISPLAYED)) * 20 / 100
		if barlength > 20 : barlength = 20
		if barlength < 0 : barlength = 0
		boxf char_sppos(i,CIE_X)+6,char_sppos(i,CIE_Y)-3,char_sppos(i,CIE_X)+6+barlength,char_sppos(i,CIE_Y)
	next
	
	; 全体の色蓄積情報

	dim perc,TEAM_MAX
	if map_bucket_globalsum > 0 {
		for i,0,TEAM_MAX
			perc(i) = map_bucket_sum(i) * 300 / map_bucket_globalsum
		next
	}

	color 64,64,64
	boxf 10,323,10+300,327
	point = 0
	for i,0,TEAM_MAX
		color team_info(i,COLOR_R),team_info(i,COLOR_G),team_info(i,COLOR_B)
		boxf 10+point,323,10+point+perc(i),327
		point += perc(i)
	next
	
	return

; スプライトの表示位置計算
*spplot
	; キャラクタの表示位置計算
	for i,0,CHAR_MAX
		if char_spid(i,CHAR_SPID_MAP)!0 {
			char_sppos(i,CIE_X) = (char_mappos(i,CIE_X)-MAP_MERGIN)*32
			char_sppos(i,CIE_Y) = (char_mappos(i,CIE_Y)-MAP_MERGIN)*32
		}
	next
	; 弾丸の表示位置計算
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			bullet_sppos(i,CIE_X) = (bullet_mappos(i,CIE_X)-MAP_MERGIN)*32
			bullet_sppos(i,CIE_Y) = (bullet_mappos(i,CIE_Y)-MAP_MERGIN)*32
		}
	next
	return

; スプライトの位置反映
*sppos
	; キャラクタの表示位置反映
	for i,0,CHAR_MAX
		if char_spid(i,CHAR_SPID_MAP)!0 {
			es_pos char_spid(i,CHAR_SPID_MAP),char_sppos(i,CIE_X),char_sppos(i,CIE_Y) ; スプライトの画面表示位置について保持情報を反映
			; ポップアップの位置修正
			if char_spid(i,CHAR_SPID_POPUP)!0 {
				es_pos char_spid(i,CHAR_SPID_POPUP),char_sppos(i,CIE_X),char_sppos(i,CIE_Y)-32
			}
		} else {
			; 戦闘不能状態の場合、ポップアップは見えないように
			if char_spid(i,CHAR_SPID_POPUP)!0 {
				es_pos char_spid(i,CHAR_SPID_POPUP),-32,-32
			}
		}
	next
	; 弾丸の表示位置反映
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			es_pos bullet_spid(i),bullet_sppos(i,CIE_X),bullet_sppos(i,CIE_Y) ; スプライトの画面表示位置について保持情報を反映
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN ){ ; 弾丸を下向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_DOWN
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT ){ ; 弾丸を左向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_LEFT
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP ){ ; 弾丸を上向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_UP
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT ){ ; 弾丸を右向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_RIGHT
			}
		}
	next
	return

; 入力キー確認 
*checkinput
	; キー入力を処理
	dim rest,5
	getkey rest(0),37 ; カーソルキー[←]
	getkey rest(1),38 ; カーソルキー[↑]
	getkey rest(2),39 ; カーソルキー[→]
	getkey rest(3),40 ; カーソルキー[↓]

	getkey rest(4),90 ; zキー
	getkey rest(5),88 ; xキー
	getkey rest(6),67 ; cキー
	

	; キー入力を処理（ゆくゆくは行動の処理に移管）
	if rest(0)=1 {	; 左を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_LEFT
	}
	if rest(1)=1 {	; 上を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_UP
	}
	if rest(2)=1 {	; 右を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT
	}
	if rest(3)=1 {	; 下を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_DOWN
	}
	if rest(6)=1 {	; cキーを検知
		char_info(0,CHAR_INFO_NEXTACT) = 3
	} else {
		if rest(5)=1 {	; xキーを検知
			char_info(0,CHAR_INFO_NEXTACT) = 2
		} else {
			if rest(4)=1 {	; zキーを検知
				char_info(0,CHAR_INFO_NEXTACT) = 1
			}
		}
	}

	return

; 主人公以外の行動の決定
*comthink
	getreq record_comthink(0,0),SYSREQ_TIMER
	for i,0,CHAR_MAX
		getreq record_comthink(i+1,0),SYSREQ_TIMER
		for j,1,8
			record_comthink(i+1,j) = record_comthink(i+1,0)
		next
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue						; 有効でない場合は何もしない
		if DEBUG_MODE : logmes "I call *comthink charid="+i+", CTRLMODE="+char_info(i,CHAR_INFO_CTRLMODE)
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_MANUAL : _continue	; MANUALの場合は何もしない
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_NOACT : _continue	; NOACTの場合は何もしない
		if char_info(i,CHAR_INFO_STATEACTIVE_STAN) > 0 : _continue		; ステート：スタンだったら何もしない
		if ( char_info(i,CHAR_INFO_MOVEHEAT) > 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) > 0 ) : _continue	; 行動、武器1がクールダウンタイム中なら何もしない

		getreq record_comthink(i+1,1),SYSREQ_TIMER ; 無視判定まで
		
		x = char_mappos(i,CIE_X)
		y = char_mappos(i,CIE_Y)

		; WPが少ない場合は自チームの床を目指す
		if char_info(i,CHAR_INFO_WP) < 20 {
			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 8
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考(低WPモード) charid="+i+"("+char_desc(i,0)+"), 座標="+char_mappos(i,CIE_X)+","+char_mappos(i,CIE_Y)+", 足元の認識="+map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))
			if map_steps_allycolormove_cnt > 0 {
				char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_allycolormove(rnd(map_steps_allycolormove_cnt))
				return ; 移動先があるなら他には何もしない（なければ元のルーチンに従う）
			}
		}
		
		; CHAR_CTRLMODE_RANDOMの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_RANDOM {
			if DEBUG_MODE : logmes "D ランダムモード charid="+i

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐

			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 4
			gosub *sub_calc_map_steps
			
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+x+","+y+", 足元の認識="+map_steps_info(x,y)

			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成

			; 武器1が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON1) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 1
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER {
					; 足元が色蓄積がない、ほぼない（50以下）の場合
					if map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR {
						; 60%の確率で武器1を使う
						if rnd(100) < 60 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}
		
					getreq record_comthink(i+1,4),SYSREQ_TIMER ; NOCOLOR判断
		
					; 足元が敵チームの色（十分塗られている、50より多い）の場合
					if map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR {
						; 80%の確率で武器1を使う
						if rnd(100) < 80 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}
				}
			}
			
			; 武器2が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON2) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 2
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 2
					}
				}
			}

			; 武器3が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON3) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 3
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 3
					}
				}
			}

			getreq record_comthink(i+1,5),SYSREQ_TIMER ; ENEMYCOLOR判断
			
			; 足元が自チームの色（十分塗られている、50より多い）の場合
			if map_steps_info(x,y)&MAP_STEPS_INFO_ALLYCOLOR {
				; 80%の確率で移動する
				if rnd(100) < 80 {
					; 60%の確率で向いている方向に移動する
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; MAP_STEPS_INFO_ALLYCOLOR判断
			
		}
		; CHAR_CTRLMODE_RANDOM2の場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_RANDOM2 {
			if DEBUG_MODE : logmes "D ランダムモード charid="+i

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐

			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 4
			gosub *sub_calc_map_steps
			
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+x+","+y+", 足元の認識="+map_steps_info(x,y)

			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成

			; 武器1が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON1) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 1
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER {

					; 足元が色蓄積がない、ほぼない（50以下）の場合
					if map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR {
						; 95%の確率で武器1を使う
						if rnd(100) < 95 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}
		
					getreq record_comthink(i+1,4),SYSREQ_TIMER ; NOCOLOR判断
		
					; 足元が敵チームの色（十分塗られている、50より多い）の場合
					if map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR {
						; 99%の確率で武器1を使う
						if rnd(100) < 99 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}
				}
			}
			
			; 武器2が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON2) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 2
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 2
					}
				}
			}

			; 武器3が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON3) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 3
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 3
					}
				}
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; ENEMYCOLOR判断
			
			; 足元が自チームの色（十分塗られている、50より多い）の場合
			if map_steps_info(x,y)&MAP_STEPS_INFO_ALLYCOLOR {
				; 95%の確率で移動する
				if rnd(100) < 95 {
					; 60%の確率で向いている方向に移動する
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; MAP_STEPS_INFO_ALLYCOLOR判断
			
		}
		; CHAR_CTRLMODE_NOMOVEの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_NOMOVE {

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐

			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 4
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+x+","+y+", 足元の認識="+map_steps_info(x,y)

			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 50%の確率で向きを変える
			if rnd(100) < 50 {
				if map_steps_canmove_cnt > 0 {
					direc = map_steps_canmove(rnd(map_steps_canmove_cnt))
					if direc ! char_info(i,CHAR_INFO_DIREC) : char_info(i,CHAR_INFO_NEXTMOVE) = direc
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 向き変更判定

			; 武器1が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON1) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 1
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER {
					; 70%の確率で武器1を使う
					if rnd(100) < 70 {
						char_info(i,CHAR_INFO_NEXTACT) = 1
					}
				}
			}
			
			; 武器2が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON2) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 2
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 2
					}
				}
			}

			; 武器3が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON3) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 3
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 3
					}
				}
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; 攻撃判定
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; 
			
		}
		; CHAR_CTRLMODE_PAINTERの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_PAINTER {

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐
			
			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = char_mappos(i,CIE_X)
			sub_calc_map_steps_posy = char_mappos(i,CIE_Y)
			sub_calc_map_steps_flag = 5
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+char_mappos(i,CIE_X)+","+char_mappos(i,CIE_Y)+", 足元の認識="+map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))
			
			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 移動先は最寄りの色が塗れる場所
			if map_steps_nocolormove_cnt > 0 {
				char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_nocolormove(rnd(map_steps_nocolormove_cnt))
			} else {
				; 90%の確率で移動する
				if rnd(100) < 90 {
					; 70%の確率で向いている方向に移動する
					if rnd(100) < 70 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 移動先判定

			; 武器1が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON1) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 1
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER {

					; 足元が色蓄積がない、ほぼない（50以下）の場合
					if map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))&MAP_STEPS_INFO_NOCOLOR {
						; 90%の確率で武器1を使う
						if rnd(100) < 90 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}
					
					getreq record_comthink(i+1,5),SYSREQ_TIMER ; NOCOLOR判定
					
					; 足元が敵チームの色（十分塗られている、50より多い）の場合
					if map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))&MAP_STEPS_INFO_ENEMYCOLOR {
						; 95%の確率で武器1を使う
						if rnd(100) < 95 {
							char_info(i,CHAR_INFO_NEXTACT) = 1
						}
					}			
				}
			}
			
			; 武器2が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON2) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 2
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 2
					}
				}
			}

			; 武器3が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON3) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 3
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 3
					}
				}
			}
			
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; ENEMYCOLOR判定
			
		}
		; CHAR_CTRLMODE_ATTACKERの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_ATTACKER {
			
			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐
			
			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = char_mappos(i,CIE_X)
			sub_calc_map_steps_posy = char_mappos(i,CIE_Y)
			sub_calc_map_steps_flag = 2
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+char_mappos(i,CIE_X)+","+char_mappos(i,CIE_Y)+", 足元の認識="+map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))
			
			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 移動先は主人公へ
			if map_steps_enemymove_cnt > 0 {
				char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_enemymove(rnd(map_steps_enemymove_cnt))
				if DEBUG_MODE : logmes "D 行動の思考 移動先は主人公へ"
			} else {
				; 60%の確率で移動する
				if rnd(100) < 60 {
					; 60%の確率で向いている方向に移動する
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 移動先判定

			; 武器1が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON1) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 1
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER {

					; 60%の確率で武器1を使う
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTACT) = 1
					}			
				}
			}
			
			; 武器2が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON2) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 2
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 2
					}
				}
			}

			; 武器3が使用可能な場合
			if ( char_info(i,CHAR_INFO_WEAPON3) >= 0 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
				; 使えるなら即使うの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY {
					char_info(i,CHAR_INFO_NEXTACT) = 3
				}
				; 色が塗れるなら塗るの場合
				if char_info(i,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_PAINTER {
					if ( map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR ){
						char_info(i,CHAR_INFO_NEXTACT) = 3
					}
				}
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; 武器判定
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; 
			
		}
		getreq record_comthink(i+1,7),SYSREQ_TIMER
	next

	; 処理時間の計算
	for i,0,CHAR_MAX
		rangetime_comthink(i,0) = record_comthink(i+1,7) - record_comthink(i+1,0)
		for j,0,8-1
			rangetime_comthink(i,j+1) = record_comthink(i+1,j+1) - record_comthink(i+1,j)
		next
	next
	; 処理時間のロギング
	for i,0,CHAR_MAX
		if DEBUG_MODE : logmes strf("D charid=%d : time=%s(%s,%s,%s,%s,%s,%s,%s)",i,rangetime_comthink(i,0),rangetime_comthink(i,1),rangetime_comthink(i,2),rangetime_comthink(i,3),rangetime_comthink(i,4),rangetime_comthink(i,5),rangetime_comthink(i,6),rangetime_comthink(i,7) )
	next
	
	return

; 行動の処理
*execact
	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない
		if char_info(i,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしてたら何もしない
		if char_info(i,CHAR_INFO_STATEACTIVE_STAN) > 0 : _continue		; ステート：スタンだったら何もしない
		
		; 再装填速度 = 基本値 x ( 100 - value ) /100
		cooldownrate = 100 - char_info(i,CHAR_INFO_BUFFVALUE_COOLDOWN)
		if cooldownrate < 25 : cooldownrate = 25
		; 通常攻撃を処理
		if ( char_info(i,CHAR_INFO_NEXTACT) = 1 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON1), WEAPON_INFO_COSTWP) * ( 100 - char_info(i,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100 {
				; 1番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON1)
				gosub *sub_create_bullet
				char_info(i,CHAR_INFO_WEAPON1HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON1), WEAPON_INFO_COOLDOWN) * cooldownrate / 100
			}
		}
		if ( char_info(i,CHAR_INFO_NEXTACT) = 2 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON2), WEAPON_INFO_COSTWP) * ( 100 - char_info(i,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100 {
				; 2番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON2)
				gosub *sub_create_bullet
				
				char_info(i,CHAR_INFO_WEAPON2HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON2), WEAPON_INFO_COOLDOWN) * cooldownrate / 100
			}
		}
		if ( char_info(i,CHAR_INFO_NEXTACT) = 3 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON3), WEAPON_INFO_COSTWP) * ( 100 - char_info(i,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100 {
				; 3番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON3)
				gosub *sub_create_bullet
				
				char_info(i,CHAR_INFO_WEAPON3HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON3), WEAPON_INFO_COOLDOWN) * cooldownrate / 100
			}
		}
		; 移動を処理
		if ( char_info(i,CHAR_INFO_NEXTMOVE) ! DIREC_NONE ) and ( char_info(i,CHAR_INFO_MOVEHEAT) <= 0 ) {
			flag_move = 1
			; 移動先を afterx, afteryに入れる
			afterx = char_mappos(i,CIE_X)
			aftery = char_mappos(i,CIE_Y)
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_LEFT  ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_LEFT  ) : afterx -= 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_UP    ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_UP    ) : aftery -= 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_RIGHT ) : afterx += 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_DOWN  ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN  ) : aftery += 1

			; 侵入不可マスなら移動しない
			if map_info(afterx, aftery, MAP_INFO_TYPE) = MAP_TYPE_IMPOSSIBLE {
				flag_move = 0
			}
			for j,0,CHAR_MAX
				if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は無視する
				if char_info(j,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしてたら無視する
				if i = j : _continue								; 自分だったら無視する
				; 既にキャラがいたら移動しない
				if ( char_mappos(j,CIE_X) = afterx ) and ( char_mappos(j,CIE_Y) = aftery ) {
					flag_move = 0
				}
			next
			
			; 移動の成功失敗を問わず、向きの設定とスプライトの向きを変える
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_LEFT {
				char_info(i,CHAR_INFO_DIREC) = DIREC_LEFT
				es_chr char_spid(i,CHAR_SPID_MAP),char_spcharid(i,DIREC_LEFT) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_UP {
				char_info(i,CHAR_INFO_DIREC) = DIREC_UP
				es_chr char_spid(i,CHAR_SPID_MAP),char_spcharid(i,DIREC_UP) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT {
				char_info(i,CHAR_INFO_DIREC) = DIREC_RIGHT
				es_chr char_spid(i,CHAR_SPID_MAP),char_spcharid(i,DIREC_RIGHT) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_DOWN {
				char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
				es_chr char_spid(i,CHAR_SPID_MAP),char_spcharid(i,DIREC_DOWN) ; スプライトの向きを変更
			}
			
			if flag_move = 1 {
				; 移動可能なのでキャラを移動する
				char_mappos(i,CIE_X) = afterx
				char_mappos(i,CIE_Y) = aftery
				; 移動出来たらクールダウンタイムを設定
				char_info(i,CHAR_INFO_MOVEHEAT) = char_info(i,CHAR_INFO_MOVEFREQ_B)
			}
		}

		; 実行の有無を問わず次の移動・行動は削除（先行入力した分を予期せず動作してしまうため）
		char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_NONE
		char_info(i,CHAR_INFO_NEXTACT) = 0
		; 全てのクールダウンタイムの減少
		if char_info(i,CHAR_INFO_MOVEHEAT) > 0    : char_info(i,CHAR_INFO_MOVEHEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON1HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON1HEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON2HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON2HEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON3HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON3HEAT) -= 1
		
		; キャラクタの位置が場所の上限を超えたら調整
		if char_mappos(i,CIE_X)<0 : char_mappos(i,CIE_X)=0
		if char_mappos(i,CIE_Y)<0 : char_mappos(i,CIE_Y)=0
		if char_mappos(i,CIE_X)>MAP_X : char_mappos(i,CIE_X)=MAP_X
		if char_mappos(i,CIE_Y)>MAP_Y : char_mappos(i,CIE_Y)=MAP_Y

	next
	
	return
	
; 弾丸の処理
*execbullet
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			if DEBUG_MODE : logmes "I 弾丸の処理開始 bullet id="+i
			flag_move = 0
			flag_hit = 0
			dim hit_char,CHAR_MAX
			hit_char_cnt = 0
			flag_spread = 0
			flag_delete = 0

			; 移動可能かどうか判定（移動しない弾丸は判定しない）
			if ( bullet_info(i,BULLET_INFO_SPPED) > 0 ) and ( bullet_info(i,BULLET_INFO_NOWSPREAD) = 0 )  {
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN {
					if map_info(bullet_mappos(i,CIE_X)  , bullet_mappos(i,CIE_Y)+1) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は下に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT {
					if map_info(bullet_mappos(i,CIE_X)-1, bullet_mappos(i,CIE_Y)  ) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は左に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP {
					if map_info(bullet_mappos(i,CIE_X)  , bullet_mappos(i,CIE_Y)-1) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は上に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT {
					if map_info(bullet_mappos(i,CIE_X)+1, bullet_mappos(i,CIE_Y)  ) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は右に移動可能 bullet id="+i
					}
				}
				; 移動できなければ拡散か消滅
				if flag_move = 0 {
					; AUTOSPREADが1のため拡散
					if bullet_info(i,BULLET_INFO_AUTOSPREAD) = 1 {
						flag_spread = 1
						if DEBUG_MODE : logmes "D 弾丸は拡散判定 bullet id="+i
					}
					; AUTOSPREADが0のため消滅
					if bullet_info(i,BULLET_INFO_AUTOSPREAD) = 0 {
						flag_delete = 1
						if DEBUG_MODE : logmes "D 弾丸は消滅判定 bullet id="+i
					}
				}
			}
			
			; 命中の判定
			if bullet_info(i,BULLET_INFO_RESTHIT) > 0{ ; HIT数が残っている
				for j,0,CHAR_MAX
					if ( char_info(j,CHAR_INFO_ACTIVE) = 1 ) and ( char_info(j,CHAR_INFO_DOWN) = 0 ) {
						if char_mappos(j,CIE_X) = bullet_mappos(i,CIE_X) and char_mappos(j,CIE_Y) = bullet_mappos(i,CIE_Y) { ; キャラと座標が一致
							if bullet_info(i,BULLET_INFO_TEAM) ! char_info(j,CHAR_INFO_TEAM) { ; 弾丸とキャラのチームが異なれば命中
								flag_hit = 1
								hit_char(hit_char_cnt) = j
								hit_char_cnt += 1
								if DEBUG_MODE : logmes "D 弾丸は命中判定 bullet id="+i
							}
						}
					}
				next
			}
			; 拡散、消滅の判定
			;;RESTRANGEが0、AUTOSPREADが1のため拡散
			if ( bullet_info(i,BULLET_INFO_RESTRANGE) <= 0 ) and ( bullet_info(i,BULLET_INFO_AUTOSPREAD) = 1 ) {
				flag_spread = 1
				if DEBUG_MODE : logmes "D 弾丸は拡散判定 bullet id="+i
			}
			;;RESTRANGEが0、AUTOSPREADが0のため消滅
			if ( bullet_info(i,BULLET_INFO_RESTRANGE) <= 0 ) and ( bullet_info(i,BULLET_INFO_AUTOSPREAD) = 0 ) {
				flag_delete = 1
				if DEBUG_MODE : logmes "D 弾丸は消滅判定 bullet id="+i
			}
			; ; 拡散持続の判定（あとで実装）
			if ( bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 ) and ( bullet_info(i,BULLET_INFO_RESTSPREAD) > 0 ) {
				flag_spread = 1
				if DEBUG_MODE : logmes "D 弾丸は拡散判定(継続) bullet id="+i
			}
			; 命中、拡散の実行
			if ( flag_hit = 1 ) or ( flag_spread = 1 ) {

				; 命中ならHIT数を減らす
				if flag_hit = 1 : bullet_info(i,BULLET_INFO_RESTHIT) -= 1

				; 命中音を鳴らす
				if bullet_info(i,BULLET_INFO_SOUND_HIT) > 0 {
					mmplay bullet_info(i,BULLET_INFO_SOUND_HIT)	; 命中の効果音
				}

				if ( bullet_info(i,BULLET_INFO_RESTHIT) > 0 ) and ( flag_spread = 0 ) { ; HIT数が残っており拡散判定ではない
					; 拡散状態にはしない
				}
				else {
					bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 ; 拡散状態にする
				}
				sub_calc_map_steps_posx = bullet_mappos(i,CIE_X)
				sub_calc_map_steps_posy = bullet_mappos(i,CIE_Y)
				sub_calc_map_steps_flag = 0
				gosub *sub_calc_map_steps

				; 拡散状態であればSPREADの範囲まで、そうでなければ震源地のみ処理する
				max_r = bullet_info(i,BULLET_INFO_SPREAD)+1
				if bullet_info(i,BULLET_INFO_NOWSPREAD) = 0 : max_r = 1
				
				for r,0,max_r ; 0からmax_rまで処理(for文の終値は含まないなので+1)
					for y,0,MAP_Y ; 効率は悪いが震源地から順番に処理していく 
						for x,0,MAP_X
							if map_steps(x,y) = r { ; 命中、拡散の処理をするマス
								weaken = 100 ; 減衰率
								for w,0,r ; r=0の時は何もしない、r=1の時は1回掛け算、r=2の時は2回掛け算
									weaken = weaken * bullet_info(i,BULLET_INFO_WEAKEN) / 100
								next
								; キャラへのダメージ処理
								for j,0,CHAR_MAX
									if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; アクティブでなければ無視
									if char_info(j,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしていたら無視
									if bullet_info(i,BULLET_INFO_TEAM) = char_info(j,CHAR_INFO_TEAM) : _continue	; 自チームの弾丸は判定しない
									
									if ( char_mappos(j,CIE_X) = x ) and ( char_mappos(j,CIE_Y) = y ) {
										damage = bullet_info(i,BULLET_INFO_ATC) * weaken / 100 - char_info(j,CHAR_INFO_DEF_B)
										if damage > 0 {
											char_info(j,CHAR_INFO_DAMAGEHP) += damage
										}
										else { ; 最低でも1ダメージは入る
											char_info(j,CHAR_INFO_DAMAGEHP) += 1
										}
										; 確率でステートを付与
										if bullet_info(i,BULLET_INFO_ADDSTATE) != STATE_TYPE_NONE{
											logmes strf("D 弾丸はステート付与を試行 bullet id=%d, target char=%d, state=%d, rate=%d",i,j,bullet_info(i,BULLET_INFO_ADDSTATE),bullet_info(i,BULLET_INFO_ADDSTATERATE))
											addstaterate_change = 100 
											; パッシブスキル判定（相手が特定のステートだった場合、ステート付与率を変える）
											if passive_info(bullet_info(i,BULLET_INFO_PASSIVE),PASSIVE_INFO_FLAG) = PASSIVE_FLAG_STATEADDUP {
												target_state = passive_info(bullet_info(i,BULLET_INFO_PASSIVE),PASSIVE_INFO_VALUE1)
												; 対象キャラが特定のステートの場合
												if char_info(j,CHAR_INFO_STATE_BEGIN+target_state) {
													addstaterate_change = 100 + passive_info(bullet_info(i,BULLET_INFO_PASSIVE),PASSIVE_INFO_VALUE3)
												}
											}

											; ステート付与判定
											if rnd(100) < ( bullet_info(i,BULLET_INFO_ADDSTATERATE) * addstaterate_change / 100) {
												sub_set_state_charid   = j
												sub_set_state_resttime = bullet_info(i,BULLET_INFO_ADDSTATETIME)
												sub_set_state_type     = bullet_info(i,BULLET_INFO_ADDSTATE)
												gosub *sub_set_state
											}
										}
									}
								next
								; 色蓄積
								; 弾丸のTEAM色に 色蓄積力（対バケツ）× 減衰率 分蓄積する
								map_bucket(x,y,bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORPOWER) * weaken / 100
								if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+x+", y="+y+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORPOWER) * weaken / 100

							}
						next
					next
				next

				; 弾丸を消去（拡散状態を継続できない場合）
				if ( flag_spread = 1 ) and ( bullet_info(i,BULLET_INFO_RESTSPREAD) <= 0 ) {
					sub_delete_bullet_bulletid = i
					gosub *sub_delete_bullet
					if DEBUG_MODE : logmes "D 弾丸は消去 bullet id="+i
					_break ; 次の弾丸の処理に移動
				}
			}
			; 消滅の実行
			if flag_delete = 1 {
				if bullet_info(i,BULLET_INFO_COLORFLY) > 0 {
					; 消滅時も飛翔時の色蓄積は実行する
					map_bucket(bullet_mappos(i,CIE_X),bullet_mappos(i,CIE_Y),bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORFLY)
					if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+bullet_mappos(i,CIE_X)+", y="+bullet_mappos(i,CIE_Y)+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORFLY)
				}
				; 弾丸を消去
				sub_delete_bullet_bulletid = i
				gosub *sub_delete_bullet
				if DEBUG_MODE : logmes "D 弾丸は消去 bullet id="+i
				_break ; 次の弾丸の処理に移動
			}
			; 飛翔時の色蓄積の実行
			if bullet_info(i,BULLET_INFO_COLORFLY) > 0 {
				map_bucket(bullet_mappos(i,CIE_X),bullet_mappos(i,CIE_Y),bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORFLY)
				if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+bullet_mappos(i,CIE_X)+", y="+bullet_mappos(i,CIE_Y)+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORFLY)
			}
			; 移動の実行
			if flag_move = 1 {
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN  : bullet_mappos(i,CIE_Y) += 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT  : bullet_mappos(i,CIE_X) -= 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP    : bullet_mappos(i,CIE_Y) -= 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT : bullet_mappos(i,CIE_X) += 1
				if DEBUG_MODE : logmes "D 弾丸の移動を実行 bullet id="+i
			}
			; RESTRANGE, RESTSPREADの減少
			bullet_info(i,BULLET_INFO_RESTRANGE) -= 1
			if bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 {
				bullet_info(i,BULLET_INFO_RESTSPREAD) -= 1
			}
			if DEBUG_MODE : logmes "I 弾丸の処理を終了 bullet id="+i+", RESTRANGE="+bullet_info(i,BULLET_INFO_RESTRANGE)+", RESTSPREAD="+bullet_info(i,BULLET_INFO_RESTSPREAD)
		}
	next
	
	return

; 色蓄積の計算
*culcbucket
	
	dim map_bucket_sum,TEAM_MAX	; 全体の累積の色蓄積を初期化
	for x,0,MAP_X
		for y,0,MAP_Y
			sum = 0
			sumc = 0
			max = 0
			maxt = -1
			for z,0,TEAM_MAX
				if map_bucket(x,y,z) > 0 {
					map_bucket_sum(z) += map_bucket(x,y,z)
					sum += map_bucket(x,y,z)
					sumc += 1
					if map_bucket(x,y,z) > max {
						max = map_bucket(x,y,z)
						maxt = z
					}
				}
			next
			; 全体の色蓄積を計算
			map_bucket_globalsum = 0
			for z,0,TEAM_MAX
				map_bucket_globalsum += map_bucket_sum(z)
			next
			; 1マスに合計で100を超えた場合は超えた分だけ各チームの色蓄積を減算（端数の都合で減算後に100を超える場合もあるが気にしない）
			if sum > 100{
				cut = (sum-100)/sumc
				for z,0,TEAM_MAX
					if map_bucket(x,y,z) > 0 : map_bucket(x,y,z) -= cut
				next
			}
			; 上限制御
			for z,0,TEAM_MAX
				if map_bucket(x,y,z) > 100 : map_bucket(x,y,z) = 100
				if map_bucket(x,y,z) <   0 : map_bucket(x,y,z) =   0
			next			
			; 最も色蓄積が多いチームをleadに設定
			if max > 0 {
				map_bucket_lead(x,y) = maxt
			} else {
				map_bucket_lead(x,y) = -1
			}
		next
	next
	
	return

; キャラへのダメージ処理
*execdamage
	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない

		; HPとWPの上限処理をしておく
		if char_info(i,CHAR_INFO_HP) < 0                              : char_info(i,CHAR_INFO_HP) = 0
		if char_info(i,CHAR_INFO_HP) > char_info(i,CHAR_INFO_MAXHP_B) : char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP_B)
		if char_info(i,CHAR_INFO_WP) < 0                              : char_info(i,CHAR_INFO_WP) = 0
		if char_info(i,CHAR_INFO_WP) > char_info(i,CHAR_INFO_MAXWP_B) : char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP_B)

		; 現在ダウンしていない場合
		if char_info(i,CHAR_INFO_DOWN) = 0{
			; バリア状態の場合、ダメージは無効化
			if char_info(i,CHAR_INFO_STATEACTIVE_BARRIER) > 0 {
				char_info(i,CHAR_INFO_DAMAGEHP) = 0
			}
			; 覚醒状態の場合、ダメージは半分
			if char_info(i,CHAR_INFO_STATEACTIVE_AWAKE) > 0 {
				char_info(i,CHAR_INFO_DAMAGEHP) = char_info(i,CHAR_INFO_DAMAGEHP) / 2
			}
			; ダメージがあればHPに反映
			if char_info(i,CHAR_INFO_DAMAGEHP) {
				char_info(i,CHAR_INFO_HP) -= char_info(i,CHAR_INFO_DAMAGEHP)

				; ダメージの数字を表示
				if ( char_sppos(i,CIE_X) != -1 ) or ( char_sppos(i,CIE_Y) != -1 ) {
					sub_show_damage_value= char_info(i,CHAR_INFO_DAMAGEHP) * -1
					sub_show_damage_x = char_sppos(i,CIE_X)
					sub_show_damage_y = char_sppos(i,CIE_Y)
					gosub *sub_show_damage
				}

				; 上限・下限処理
				if char_info(i,CHAR_INFO_HP) < 0 : char_info(i,CHAR_INFO_HP) = 0
				if char_info(i,CHAR_INFO_HP) > char_info(i,CHAR_INFO_MAXHP_B) : char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP_B)
				char_info(i,CHAR_INFO_DAMAGEHP) = 0
			}
			; ダメージがあればWPに反映
			if char_info(i,CHAR_INFO_DAMAGEWP) {
				char_info(i,CHAR_INFO_WP) -= char_info(i,CHAR_INFO_DAMAGEWP)
				if char_info(i,CHAR_INFO_WP) < 0 : char_info(i,CHAR_INFO_WP) = 0
				if char_info(i,CHAR_INFO_WP) > char_info(i,CHAR_INFO_MAXWP_B) : char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP_B)
				char_info(i,CHAR_INFO_DAMAGEWP) = 0
			}
			; HPが半分以下
			if char_info(i,CHAR_INFO_HP) <= ( char_info(i,CHAR_INFO_MAXHP_B) / 2 ) {
				; HPが半分以下に自分にステート付与のパッシブスキル判定
				if char_info(i,CHAR_INFO_PASSIVE_HALFHPSTATE) > 0 {
					state_type = passive_info(char_info(i,CHAR_INFO_PASSIVE_HALFHPSTATE),PASSIVE_INFO_VALUE2)
					; 既にそのステートである場合は再付与しない
					if char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+state_type) <= 0 {
						sub_set_state_charid   = i
						sub_set_state_resttime = passive_info(char_info(i,CHAR_INFO_PASSIVE_HALFHPSTATE),PASSIVE_INFO_VALUE1)
						sub_set_state_type     = passive_info(char_info(i,CHAR_INFO_PASSIVE_HALFHPSTATE),PASSIVE_INFO_VALUE2)
						gosub *sub_set_state
					}
				}
			}
			
			; HPが0以下ならDOWN
			if char_info(i,CHAR_INFO_HP) <= 0 {
				; ファイナルアタック前に追加バフのパッシブスキル判定
				logmes strf("charid = %d, PASSIVE_FABUFF=%d",i,char_info(i,CHAR_INFO_PASSIVE_FABUFF))
				if char_info(i,CHAR_INFO_PASSIVE_FABUFF) > 0 {
					
					if passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE1) > 0 { ; 1つ目のバフがあれば処理
						sub_set_buff_charid   = i
						sub_set_buff_resttime = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE1)
						sub_set_buff_type     = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE2)
						sub_set_buff_value    = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE3)
						gosub *sub_set_buff
					}
					if passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE4) > 0 { ; 2つ目のバフがあれば処理
						sub_set_buff_charid   = i
						sub_set_buff_resttime = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE4)
						sub_set_buff_type     = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE5)
						sub_set_buff_value    = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE6)
						gosub *sub_set_buff
					}
					if passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE7) > 0 { ; 3つ目のバフがあれば処理
						sub_set_buff_charid   = i
						sub_set_buff_resttime = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE7)
						sub_set_buff_type     = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE8)
						sub_set_buff_value    = passive_info(char_info(i,CHAR_INFO_PASSIVE_FABUFF),PASSIVE_INFO_VALUE9)
						gosub *sub_set_buff
					}
					
					gosub *sub_recal_value	; バフの効果量に反映
				}
				
				if char_info(i,CHAR_INFO_STATEACTIVE_GIVEUP) <= 0 { ; あきらめ状態の場合はファイナルアタックしない
					; ファイナルアタックの設定があれば発射
					if char_info(i,CHAR_INFO_WEAPONFA) >= 0 {
						sub_create_bullet_charid = i
						sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPONFA)
						gosub *sub_create_bullet
					}
				}
				
				char_info(i,CHAR_INFO_DOWN) = 1
				if char_info(i,CHAR_INFO_TEAM) = 0 {
					mmplay sound_def_mediabuffid(SOUND_DEF_DOWN_ALLY)	; ダウンの効果音
				} else {
					mmplay sound_def_mediabuffid(SOUND_DEF_DOWN_ENEMY)	; ダウンの効果音
				}
				es_fade char_spid(i,CHAR_SPID_MAP),ESSPF_BLINKWIPE2,30 ; スプライトはゆっくり点滅し消滅
				char_spid(i,CHAR_SPID_MAP) = 0
				; リスポーン可能な場合
				if char_info(i,CHAR_INFO_RESTRESPAWN) > 0{
					char_info(i,CHAR_INFO_RESTDOWNTIME) = char_info(i,CHAR_INFO_DOWNTIME_B)
					char_info(i,CHAR_INFO_RESTRESPAWN) -= 1
				} else {
					; リスポーンできない場合はダウン時に消去
					char_info(i,CHAR_INFO_ACTIVE) = 0
				}
			}
		} else {
			; 既にダウンしている場合
			char_info(i,CHAR_INFO_RESTDOWNTIME) -= 1
			; リスポーンできる場合
			if char_info(i,CHAR_INFO_RESTDOWNTIME) <=0 {
				; 誰かがいたらリスポーンできない
				flag_respawn = 1
				for j,0,CHAR_MAX
					if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; アクティブでなければ無視
					if i = j : _continue	; 自キャラは無視
					if ( char_mappos(j,CIE_X) = char_basepos(i,CIE_X) ) and ( char_mappos(j,CIE_Y) = char_basepos(i,CIE_Y) ) {
						flag_respawn = 0
					}
				next
				if flag_respawn = 1 {
					; リスポーン処理（リスポーン地点に移動、全回復）
					char_mappos(i,CIE_X) = char_basepos(i,CIE_X)
					char_mappos(i,CIE_Y) = char_basepos(i,CIE_Y)
					char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
					char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP_B)
					char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP_B)
					char_info(i,CHAR_INFO_DAMAGEHP) = 0
					char_info(i,CHAR_INFO_DAMAGEWP) = 0
					char_info(i,CHAR_INFO_DOWN) = 0
					char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_NONE
					char_info(i,CHAR_INFO_NEXTACT) = 0
					mmplay sound_def_mediabuffid(SOUND_DEF_RESPAWN)	; リスポーンの効果音
					; スプライト再生成
					es_set SP_MAP+i,0,0,defchar_sp(char_info(i,CHAR_INFO_DEFINECHAR),DEFCHAR_SP_ANIME_DOWN),0,5 ; MAP上キャラ、アニメキャラ（下向き）
					char_spid(i,CHAR_SPID_MAP) = SP_MAP+i

					; 復活直後はバリア状態
					sub_set_state_charid=i
					sub_set_state_resttime=50
					sub_set_state_type=STATE_TYPE_BARRIER
					gosub *sub_set_state
	
					; 復活時にリスポーン地点に弾丸発射
					if char_info(i,CHAR_INFO_RESPAWNWEAPON) >= 0 {
						sub_create_bullet_charid = i
						sub_create_bullet_weaponid = char_info(i,CHAR_INFO_RESPAWNWEAPON)
						gosub *sub_create_bullet
					}
				} else {
					; 不正処理になりそうなので、今は実装しない
					;; 誰かが塞いでいる場合は弾丸発射
					;if char_info(i,CHAR_INFO_RESPAWNWEAPON) >= 0 {
					;	char_mappos(i,CIE_X) = char_basepos(i,CIE_X)
					;	char_mappos(i,CIE_Y) = char_basepos(i,CIE_Y)
					;	char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
					;	sub_create_bullet_charid = i
					;	sub_create_bullet_weaponid = char_info(i,CHAR_INFO_RESPAWNWEAPON)
					;	gosub *sub_create_bullet
					;}						
				}
			}
		}
	next
	return

; 自然回復などの処理
*execheal
	if TIMES \ 10 ! 0 : return ; 10 TIMEに1度しか処理しない

	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない
		if char_info(i,CHAR_INFO_DOWN) = 1 : _continue	; ダウンしていれば何もしない

		; 自チームの色蓄積がなければスリップダメージ
		if map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) = 0{ 
			char_info(i,CHAR_INFO_HP) -= 1
		}
		; 自チームの色蓄積があれば自然回復
		if map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) > 0{
			; 覚醒状態の場合はHPは自然回復しない
			if char_info(i,CHAR_INFO_STATEACTIVE_AWAKE) <= 0 {
				if char_info(i,CHAR_INFO_HP) < char_info(i,CHAR_INFO_MAXHP_B){
					char_info(i,CHAR_INFO_HP) += map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) / 10
				}
			}
			if char_info(i,CHAR_INFO_WP) < char_info(i,CHAR_INFO_MAXWP_B){
				char_info(i,CHAR_INFO_WP) += map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) / 20 +5
			}
		}

		; 上限を超えていたら上限値にする
		if char_info(i,CHAR_INFO_HP) > char_info(i,CHAR_INFO_MAXHP_B) : char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP_B)
		if char_info(i,CHAR_INFO_WP) > char_info(i,CHAR_INFO_MAXWP_B) : char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP_B)
	next
	return

; バフの処理
*execbuff
	;gosub *execbuff_recal_value
	for i,0,CHAR_MAX
		; バフの効果量を初期化
		for j,0,BUFF_TYPE_MAX
			char_info(i,CHAR_INFO_BUFFVALUE_BEGIN+j) = 0
		next
		; 有効なバフを集計してバフの効果量を計算
		for j,0,BUFF_STACK_MAX
			buffindex_active = CHAR_INFO_BUFF_BEGIN+j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_ACTIVE
			buffindex_resttime = CHAR_INFO_BUFF_BEGIN+j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_RESTTIME
			buffindex_type = CHAR_INFO_BUFF_BEGIN+j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_TYPE
			buffindex_value =CHAR_INFO_BUFF_BEGIN+j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_VALUE
			
			buff_resttime = -1
			buff_type = -1
			buff_value = 0
			; バフの有無を確認
			if char_info(i,buffindex_type) > 0 {	; TYPEが0より大きい(=何かのバフあり)
				buff_type = char_info(i,buffindex_type)
				char_info(i,CHAR_INFO_BUFF_BEGIN+j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_RESTTIME) -= 1	; バフの時間消費
				if char_info(i,buffindex_resttime) <= 0 {	; 残り時間がなくなったら消滅
					char_info(i,buffindex_active) = 0
					char_info(i,buffindex_resttime) = 0
					char_info(i,buffindex_type) = 0
					char_info(i,buffindex_value) = 0
				} else {
					buff_resttime = char_info(i,buffindex_resttime)
					buff_value = char_info(i,buffindex_value)
					char_info(i,CHAR_INFO_BUFFVALUE_BEGIN+buff_type) += buff_value	; バフの効果量に加算
					; 最大HP上昇の場合は上昇量分のHPを回復する（減少の時はここでは何もしない。ダメージ反映の上限処理で調整する）
					if ( char_info(i,buffindex_active) = 0 ) and ( char_info(i,buffindex_type) = BUFF_TYPE_MAXHP ){
						if DEBUG_MODE : logmes strf("buff_value=%d Damage=%d",buff_value,char_info(i,CHAR_INFO_MAXHP) * buff_value / 100)
						if buff_value > 0 : char_info(i,CHAR_INFO_DAMAGEHP) -= char_info(i,CHAR_INFO_MAXHP) * buff_value / 100
					}
					; 最大WP上昇の場合は上昇量分のWPを回復する（減少の時はここでは何もしない。ダメージ反映の上限処理で調整する）
					if ( char_info(i,buffindex_active) = 0 ) and ( char_info(i,buffindex_type) = BUFF_TYPE_MAXWP ){
						if DEBUG_MODE : logmes strf("buff_value=%d Damage=%d",buff_value,char_info(i,CHAR_INFO_MAXWP) * buff_value / 100)
						if buff_value > 0 : char_info(i,CHAR_INFO_DAMAGEWP) -= char_info(i,CHAR_INFO_MAXWP) * buff_value / 100
					}
					; 効果量に反映したら発動状態にする
					char_info(i,buffindex_active) = 1
				}
			}
		next
		; バフ効果量を反映
		for j,0,BUFF_TYPE_MAX
			buff_value = char_info(i,CHAR_INFO_BUFFVALUE_BEGIN+j)
			if j = BUFF_TYPE_MOVE {		; 移動速度 = 基本値 x 2 / ( value /100 +2 )
										; value -100: 200%, 0: 100%, 100: 67%, 200, 50%
				if buff_value < -100 : buff_value = -100	; -100未満は-100に修正
				char_info(i,CHAR_INFO_MOVEFREQ_B) = char_info(i,CHAR_INFO_MOVEFREQ) * 2 / ( buff_value / 100 + 2 )
			}
			if j = BUFF_TYPE_MAXHP {	; 最大HP = 基本値 x ( 100 + value ) /100
				if buff_value < -100 : buff_value = -100	; -100未満は-100に修正
				char_info(i,CHAR_INFO_MAXHP_B) = char_info(i,CHAR_INFO_MAXHP) * ( 100 + buff_value ) / 100
				if char_info(i,CHAR_INFO_MAXHP_B) < 1 : char_info(i,CHAR_INFO_MAXHP_B) = 1	; 最低でも1を保証
			}
			if j = BUFF_TYPE_MAXWP {	; 最大WP = 基本値 x ( 100 + value ) /100
				if buff_value < -100 : buff_value = -100	; -100未満は-100に修正
				char_info(i,CHAR_INFO_MAXWP_B) = char_info(i,CHAR_INFO_MAXWP) * ( 100 + buff_value ) / 100
				if char_info(i,CHAR_INFO_MAXWP_B) < 10 : char_info(i,CHAR_INFO_MAXWP_B) = 10	; 最低でも10を保証
			}
			if j = BUFF_TYPE_DEF {		; 防御力 = 基本値 + value
				char_info(i,CHAR_INFO_DEF_B) = char_info(i,CHAR_INFO_DEF) + buff_value
				if char_info(i,CHAR_INFO_DEF_B) < 0 : char_info(i,CHAR_INFO_DEF_B) = 0	; 最低でも0を保証
			}
			if j = BUFF_TYPE_RESPAWN {		; リスポーン回数 = 基本値 + value　※一時的にはならず常に永続効果となる
				char_info(i,CHAR_INFO_RESPAWN_B) = char_info(i,CHAR_INFO_RESPAWN) + buff_value
				if char_info(i,CHAR_INFO_RESPAWN_B) < 0 : char_info(i,CHAR_INFO_RESPAWN_B) = 0	; 最低でも0を保証
				; CHAR_INFO_RESPAWNから残りリスポーン回数は*reset_varsでしか反映されないので、変動分はここで直接更新する
				char_info(i,CHAR_INFO_RESTRESPAWN) += buff_value
			}
			if j = BUFF_TYPE_DOWNTIME {	; ダウンタイム = 基本値 x 4 / ( value /100 +4 )
										; value -300: 400%, 0: 100%, 100: 80%, 200, 67%, 400, 50%
				if buff_value < -300 : buff_value = -300	; -300未満は-300に修正
				char_info(i,CHAR_INFO_DOWNTIME_B) = char_info(i,CHAR_INFO_DOWNTIME) * 4 / ( buff_value / 100 + 4 )
				if char_info(i,CHAR_INFO_DOWNTIME_B) < 30 : char_info(i,CHAR_INFO_DOWNTIME_B) = 30	; 最低でも30を保証（消滅のアニメーション分）
			}
			; 以下は弾丸生成時に反映するため、ここでは処理しない
			; 攻撃力 = 基本値 x ( 100 + value ) /100
			if j = BUFF_TYPE_ATC {	
				if DEBUG_MODE : logmes strf("ATC charid=%d buff_value=%d",i,buff_value)
			}
			; 色蓄積力 = 基本値 x ( 100 + value ) /100
			; 消費WP = 基本値 x ( 100 - value ) /100
			; 射程 = 基本値 + value
			; 拡散範囲 = 基本値 + value
			; 減衰率 = 基本値 + value
			; 再装填速度 = 基本値 x ( 100 - value ) /100
		next

	next
	return

; ステートの処理
*execstate
	for i,0,CHAR_MAX
		; ステートの有効フラグを初期化
		for j,0,STATE_TYPE_MAX
			char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+j) = 0
		next
		; 有効なステートを集計してステートをの有効フラグを変更
		for j,0,STATE_STACK_MAX
			index_active =   CHAR_INFO_STATE_BEGIN+j*STATE_STACK_INFO_MAX+STATE_STACK_INFO_ACTIVE
			index_resttime = CHAR_INFO_STATE_BEGIN+j*STATE_STACK_INFO_MAX+STATE_STACK_INFO_RESTTIME
			index_type =     CHAR_INFO_STATE_BEGIN+j*STATE_STACK_INFO_MAX+STATE_STACK_INFO_TYPE
			;logmes "i="+i+", index_active="+index_active+", index_resttime="+index_resttime+", index_type="+index_type
			; ステートの有無を確認
			if char_info(i,index_type) > 0 {	; TYPEが0より大きい(=何かのステートあり)
				state_type = char_info(i,index_type)
				char_info(i,index_resttime) -= 1	; ステートの時間消費
				if char_info(i,index_resttime) <= 0 {	; 残り時間がなくなったら消滅
					char_info(i,index_active) = 0
					char_info(i,index_resttime) = 0
					char_info(i,index_type) = 0
					; ポップアップのスプライトを削除（他に残っていれば後で設定される）
					if char_spid(i,CHAR_SPID_POPUP)!0 {
						if DEBUG_MODE : logmes "es_kill char_spid(i,CHAR_SPID_POPUP) i="+i+", spid="+char_spid(i,CHAR_SPID_POPUP)
						es_kill char_spid(i,CHAR_SPID_POPUP)
					}
					char_spid(i,CHAR_SPID_POPUP) = 0
					char_info(i,CHAR_INFO_STATE_DISPLAYED) = STATE_TYPE_NONE
				} else {
					if char_info(i,index_active) = 0 {
						; ステートがアクティブ化される際の1度だけの処理
						
						; ステート毎の特別な処理
						if char_info(i,index_type) = STATE_TYPE_BERSERKER {
							; 攻撃力 +150%
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 200
							sub_set_buff_type     = BUFF_TYPE_ATC
							sub_set_buff_value    = 150
							gosub *sub_set_buff
							; 色蓄積 -50%
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 200
							sub_set_buff_type     = BUFF_TYPE_COLORPOWER
							sub_set_buff_value    = -50
							gosub *sub_set_buff
							; 消費WP -50%
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 200
							sub_set_buff_type     = BUFF_TYPE_COSTWP
							sub_set_buff_value    = 50
							gosub *sub_set_buff
						}
						if char_info(i,index_type) = STATE_TYPE_ATROPHY {
							; 移動速度 -100
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 150
							sub_set_buff_type     = BUFF_TYPE_MOVE
							sub_set_buff_value    = -100
							gosub *sub_set_buff
							; 再装填速度 -100
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 150
							sub_set_buff_type     = BUFF_TYPE_COOLDOWN
							sub_set_buff_value    = -100
							gosub *sub_set_buff
						}
						if char_info(i,index_type) = STATE_TYPE_MEAT {
							; 攻撃力 +25%（難易度の調整を受ける）
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 9999
							sub_set_buff_type     = BUFF_TYPE_ATC
							sub_set_buff_value    = 25 * ( 100 + game_info(GAME_INFO_BUFF_ENEMY_FABUFF) ) /100
							gosub *sub_set_buff
						}						
						if char_info(i,index_type) = STATE_TYPE_SWEETS {
							; 防御力 +10（難易度の調整を受ける）
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 9999
							sub_set_buff_type     = BUFF_TYPE_DEF
							sub_set_buff_value    = 10 * ( 100 + game_info(GAME_INFO_BUFF_ENEMY_FABUFF) ) /100
							gosub *sub_set_buff
						}
						if char_info(i,index_type) = STATE_TYPE_STAN {
							cooldownrate = 100 - char_info(i,CHAR_INFO_BUFFVALUE_COOLDOWN)
							if cooldownrate < 25 : cooldownrate = 25

							; 武器2,3のチャージを初期化（バフは反映）
							if char_info(i,CHAR_INFO_WEAPON2) != -1 {
								char_info(i,CHAR_INFO_WEAPON2HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON2), WEAPON_INFO_COOLDOWN) * cooldownrate / 100
							}
							if char_info(i,CHAR_INFO_WEAPON3) != -1 {
								char_info(i,CHAR_INFO_WEAPON3HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON3), WEAPON_INFO_COOLDOWN) * cooldownrate / 100
							}
						}
						if char_info(i,index_type) = STATE_TYPE_AWAKE {
							; 最大HP -50%
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 9999
							sub_set_buff_type     = BUFF_TYPE_MAXHP
							sub_set_buff_value    = -50
							gosub *sub_set_buff
							; 攻撃力 +25%（難易度の調整を受ける）
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 9999
							sub_set_buff_type     = BUFF_TYPE_ATC
							sub_set_buff_value    = 25 * ( 100 + game_info(GAME_INFO_BUFF_ENEMY_FABUFF) ) /100
							gosub *sub_set_buff
							; 移動速度 +50%
							sub_set_buff_charid   = i
							sub_set_buff_resttime = 9999
							sub_set_buff_type     = BUFF_TYPE_MOVE
							sub_set_buff_value    = 50
							gosub *sub_set_buff
							char_info(i,CHAR_INFO_RESTRESPAWN) = 0	; リスポーン出来なくなる
							char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_ATTACKER ; 攻撃を重視する
							mmplay sound_def_mediabuffid(SOUND_DEF_RAISE2)	; 上昇した時2の音
							mmplay music_def_mediabuffid(MUSIC_DEF_BOSS3)	; ボスステージ3の音楽
						}

					}
					; 発動状態にする
					if char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+char_info(i,index_type)) < char_info(i,index_resttime) {
						char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+char_info(i,index_type)) = char_info(i,index_resttime)
					}
					char_info(i,index_active) = 1

					; ステート毎の特別な処理（毎ターン効果があるもの）
					if char_info(i,index_type) = STATE_TYPE_TIMEWASTE {
						; 残り時間を-1
						game_info(GAME_INFO_RESTTIME) -= 1
					}
				}
			}
		next
		num_stack = 0
		dim state_stack,STATE_TYPE_MAX
		for j,0,STATE_TYPE_MAX
			if char_info(i,CHAR_INFO_STATEACTIVE_BEGIN+j) > 0 {
				state_stack(num_stack) = j
				num_stack += 1
			}
		next
		if num_stack > 0 {
			select_state = state_stack( (TIMES / 16) \ num_stack )
			if char_spid(i,CHAR_SPID_POPUP) = 0 {
				; 有効なステートがありポップアップがない場合
				es_exnew char_spid(i,CHAR_SPID_POPUP),SP_POPUP_STATIC,-1	; 空きを探す
				es_set char_spid(i,CHAR_SPID_POPUP),-32,-32,SPCHAR_POPUP_STATIC+(state_defchar(select_state)*4),0,1
				char_info(i,CHAR_INFO_STATE_DISPLAYED) = select_state
			} else {
				; 有効なステートがありポップアップがある場合
				if char_info(i,CHAR_INFO_STATE_DISPLAYED) ! select_state {
					es_set char_spid(i,CHAR_SPID_POPUP),-32,-32,SPCHAR_POPUP_STATIC+(state_defchar(select_state)*4),0,1
					char_info(i,CHAR_INFO_STATE_DISPLAYED) = select_state
				}
			}				
		} else {
			; 有効なステートがなく、ポップアップがある場合
			if char_spid(i,CHAR_SPID_POPUP) > 0 {
				es_kill char_spid(i,CHAR_SPID_POPUP)
				char_spid(i,CHAR_SPID_POPUP) = 0
				char_info(i,CHAR_INFO_STATE_DISPLAYED) = STATE_TYPE_NONE
			}
		}
	next
	return
