	#include "hsp3dish.as"	; HSP3Dishランタイムを使用する

	randomize ; 乱数の初期化

	#include "const.hsp"		; 定数の読み込み
	#include "gloval_var.hsp"	; グローバル変数の設定
	#include "data.hsp"			; データの設定（テストデータ含む）

	#include "maidsoji_sub.hsp"	; gosubで呼び出す用の処理の読み込み


	;;; 描画系の初期化
	;screen 0,WINDOW_X,WINDOW_Y ; サイズ：WINDOW_X x WINDOW_Y（実行する際にひと手間必要になるので今はやらない）

	gsel 0			; 操作先IDを0に戻す
	font "",12


*restart_game
	clrobj
	input_button_display = 0
	game_info(GAME_INFO_NEXTSTAGE) = 1
	mmstop
	mmplay music_def_mediabuffid(MUSIC_DEF_OPENING)	; オープニングの音楽
; オープニングのメインループ
*main_opening
	redraw 0				; 画面クリア
	gosub *opening_title	; タイトル画面表示
	redraw 1				; 画面の更新
	await 1000/16		; 時間待ち(1/60秒)
	goto *main_opening

; ステージ情報のロード
*load_stage
	mmplay sound_def_mediabuffid(SOUND_DEF_DECISION)	; 決定の効果音
	clrobj
	input_button_display = 0
	gosub *reset_data		; ステージデータを読み込む前にデータの初期化
	if game_info(GAME_INFO_NEXTSTAGE) = 1 { ; ステージ1の情報読み込み
		gosub *load_data_stage1
		game_info(GAME_INFO_STAGE) = 1
	}
	if game_info(GAME_INFO_NEXTSTAGE) = 2 { ; ステージ2の情報読み込み
		gosub *load_data_stage2
		game_info(GAME_INFO_STAGE) = 2
	}
	if game_info(GAME_INFO_NEXTSTAGE) = 3 { ; ステージ3の情報読み込み
		gosub *load_data_stage3
		game_info(GAME_INFO_STAGE) = 3
	}
	if game_info(GAME_INFO_NEXTSTAGE) = 4 { ; ステージ4の情報読み込み
		gosub *load_data_stage4
		game_info(GAME_INFO_STAGE) = 4
	}
	if game_info(GAME_INFO_NEXTSTAGE) = 5 { ; ステージ5の情報読み込み
		gosub *load_data_stage5
		game_info(GAME_INFO_STAGE) = 5
	}
	if game_info(GAME_INFO_NEXTSTAGE) >= 6 { ; 終了
		goto *game_ending
	}
	gosub *reset_vars		; ゲームを始める前に全ての可変データを初期化

	; 処理時間の計測
	timeindex = 0
	sdim rangetitle,32,7
	rangetitle(0) = "入力キー確認","主人公以外の行動決定","行動の処理","弾丸の処理","色蓄積の計算","キャラのダメージ処理","自然回復などの処理"
	dim record,8,2
	dim rangetime,7,2

	dim record_comthink,CHAR_MAX+1,8
	dim rangetime_comthink,CHAR_MAX,8
	
; ゲームのメインループ
*main_game
	; 表示
	redraw 0			; 画面クリア
	gosub *gdraw 		; スプライト以外の描画
	gosub *spplot		; スプライトの表示位置計算
	gosub *sppos		; スプライトの位置反映
	es_draw				; スプライト描画
	redraw 1			; 画面の更新
	; 表示以外の処理
	await 1000/16		; 時間待ち(1/60秒)

	TIMES = TIMES +1
	game_info(GAME_INFO_RESTTIME) -= 1
	if game_info(GAME_INFO_RESTTIME) <= 0 {
		goto *end_stage	; 残り時間を過ぎたら試合終了
	}

	getreq record(0,timeindex),SYSREQ_TIMER
	gosub *checkinput 	; 入力キー確認
	getreq record(1,timeindex),SYSREQ_TIMER
	gosub *comthink 	; 主人公以外の行動の決定
	getreq record(2,timeindex),SYSREQ_TIMER
	gosub *execact		; 行動の処理
	getreq record(3,timeindex),SYSREQ_TIMER
	gosub *execbullet	; 弾丸の処理
	getreq record(4,timeindex),SYSREQ_TIMER
	gosub *culcbucket	; 色蓄積の計算
	getreq record(5,timeindex),SYSREQ_TIMER
	gosub *execdamage	; キャラへのダメージ処理
	getreq record(6,timeindex),SYSREQ_TIMER
	gosub *execheal		; 自然回復などの処理
	getreq record(7,timeindex),SYSREQ_TIMER
	
	; 処理時間の計算
	for i,0,8-1
		rangetime(i,timeindex) = record(i+1,timeindex) - record(i,timeindex)
	next

	if DEBUG_MODE : logmes strf("D TIMES=%d rangetime=%d,%d,%d,%d,%d,%d,%d",TIMES,rangetime(0,timeindex),rangetime(1,timeindex),rangetime(2,timeindex),rangetime(3,timeindex),rangetime(4,timeindex),rangetime(5,timeindex),rangetime(6,timeindex))

	timeindex = 1

	goto *main_game


; 残り時間を過ぎたら試合終了
*end_stage
	
	; 処理時間のロギング
	for i,0,8-1
		if DEBUG_MODE : logmes strf("D %s: 初期=%3d, 末期=%3d",rangetitle(i),rangetime(i,0),rangetime(i,1) )
	next
	
	if map_bucket_sum(0) > map_bucket_sum(1) { ; 勝った場合は次のステージへ
		game_info(GAME_INFO_NEXTSTAGE) += 1
		mmplay sound_def_mediabuffid(SOUND_DEF_WIN)		; 勝利の効果音
	}
	else {
		mmplay sound_def_mediabuffid(SOUND_DEF_LOSE)	; 敗北の効果音
	}
	mmstop
	mmplay music_def_mediabuffid(MUSIC_DEF_RESULT)	; リザルト画面の音楽
*main_stageend
	
	redraw 0			; 画面クリア
	gosub *result_page	; リザルト画面表示
	redraw 1			; 画面の更新
	await 1000/16		; 時間待ち(1/60秒)
	goto *main_stageend

; エンディングのメインループ
*game_ending
*main_ending
	redraw 0			; 画面クリア
	gosub *ending_title	; タイトル画面表示
	redraw 1			; 画面の更新
	await 1000/16		; 時間待ち(1/60秒)
	goto *main_ending

; タイトル画面表示
*opening_title
	font "",24
	pos 10,60
	mes "メイドさんのお掃除し隊"
	font "",12
	pos 10,110
	mes "メイドさんを操作してマップを白色に染めます"
	mes "残り時間がなくなった時にお邪魔キャラより"
	mes "多く色を塗っている状態にすれば勝利です"
	mes "全部で5ステージあります"
	pos 10,170
	mes "キー操作"
	mes "　矢印キー：キャラの移動"
	mes "　zキー：武器1を使う(近距離、通常攻撃)"
	mes "　xキー：武器2を使う(遠距離、時々使える)"
	mes "　cキー：武器3を使う(設置型爆弾、たまに使える)"
	mes "　"
	mes "　※移動は矢印キーを押し続ける感じで"
	mes "　　武器は使うときに押す感じで"
	mes "　※武器を使うにはWPが必要になります"
	mes "　　自チームの色に塗られいている場所に居れば"
	mes "　　WPは自然と回復します"
	mes "　※キャラはHPが0になると一時的に退場します"
	mes "　　その後初期位置で復活します"
	pos 10,400
	if input_button_display = 0 : button goto "ゲームスタート",*load_stage
	pos 80,432
	mes strf("version %d.%d.%d",GAME_VERSION_MAJOR,GAME_VERSION_MINOR,GAME_VERSION_PATCH)
	pos 80,444
	mes "Copyright (c) 2022 taroh77"
	pos 80,456
	mes "Released under the MIT license"
	pos 80,468
	mes "詳細はLICENSEファイルをご確認ください"
	input_button_display = 1
	return

; リザルト画面表示
*result_page	
	font "",24
	pos 10,110
	mes "メイドさんのお掃除し隊"
	font "",12
	pos 10,140
	mes "ステージ "+game_info(GAME_INFO_STAGE)+" 結果"
	pos 10,180
	for i,0,TEAM_MAX
		mes strf("%18s : 色塗り %6d",team_desc(i,0),map_bucket_sum(i) )
	next
	pos 10,220
	font "",16
	if map_bucket_sum(0) > map_bucket_sum(1) {
		mes "勝ちましたわ、当然のことです"
	}
	if map_bucket_sum(0) = map_bucket_sum(1) {
		mes "引き分けなんて、実質負けですわね"
	}
	if map_bucket_sum(0) < map_bucket_sum(1) {
		mes "負けてしまいましたわ"
	}
	pos 10,400
	if map_bucket_sum(0) > map_bucket_sum(1) {
		if input_button_display = 0 : button goto "続ける",*load_stage
	}
	if map_bucket_sum(0) = map_bucket_sum(1) {
		if input_button_display = 0 : button goto "ゲームオーバー",*restart_game
	}
	if map_bucket_sum(0) < map_bucket_sum(1) {
		if input_button_display = 0 : button goto "ゲームオーバー",*restart_game
	}
	font "",12
	input_button_display = 1
	return

; エンディング画面表示
*ending_title
	font "",24
	pos 10,110
	mes "メイドさんのお掃除し隊"
	font "",12
	pos 10,140
	mes "ゲームで遊んで頂きありがとうございました"
	pos 10,400
	if input_button_display = 0 :button goto "タイトルに戻る",*restart_game

	input_button_display = 1
	return
	
; スプライト以外の描画
*gdraw
	font "",12
	color 0,0,0: boxf  ; 全画面塗りつぶし
	color 255,255,255

	if DEBUG_MODE = 1 {
		pos 245,470 : mes strf("TIMES: %5d",TIMES )	; ゲーム内時間（デバッグ用）
	}

	pos 130,350 : mes "ステージ"
	pos 145,362 : mes strf("%2d",game_info(GAME_INFO_STAGE) )
	
	pos 130,380 : mes "残り時間"
	pos 130,392 : mes strf("%5d",game_info(GAME_INFO_RESTTIME) )

	; mapの枠線
	color 64,64,64
	for i,0,11
		line 0,i*32,320,i*32
		line i*32,0,i*32,320
	next

	; 色蓄積情報の反映
	color 255,255,255
	for x,0,MAP_REAL_X
		for y,0,MAP_REAL_Y
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TYPE) = MAP_TYPE_NORMAL {
				; 塗りつぶしで表示
				maxt = map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y)
				if map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y) >= 0 {
					maxt = map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y)
					bright = map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,maxt) ; 色蓄積100でチームカラーを80%のRGBで表現
					color team_info(maxt,COLOR_R)*bright/125,team_info(maxt,COLOR_G)*bright/125,team_info(maxt,COLOR_B)*bright/125
					;color 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100, 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100, 192*map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)/100
					boxf x*32+2, y*32+2, x*32+30, y*32+30
				}
			}
			if DEBUG_MODE = 1 {
				; 数値で表示
				; チーム0（自チーム）
				pos x*32, y*32
				color team_info(0,COLOR_R),team_info(0,COLOR_G),team_info(0,COLOR_B)
				mes map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,0)
				; チーム1
				pos x*32+16, y*32+20
				color team_info(1,COLOR_R),team_info(1,COLOR_G),team_info(1,COLOR_B)
				mes strf("%3d", map_bucket(MAP_MERGIN+x,MAP_MERGIN+y,1))

				; デバッグ用
				pos x*32+16, y*32
				color 128,64,64
				mes strf("%3d", map_steps(MAP_MERGIN+x,MAP_MERGIN+y))
				pos x*32   , y*32+20
				color 64,64,64
				mes strf("%3d", map_bucket_lead(MAP_MERGIN+x,MAP_MERGIN+y))
			}
		next
	next

	for x,0,MAP_REAL_X
		for y,0,MAP_REAL_Y
			; 侵入不可マスの表示
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TYPE) = MAP_TYPE_IMPOSSIBLE {
				color 192,0,0
				line x*32+2,y*32+2,x*32+30,y*32+30
				line x*32+30,y*32+2,x*32+2,y*32+30
			}
			; チームの拠点の表示
			if map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TEAMBASE) >= 0 {
				t = map_info(MAP_MERGIN+x,MAP_MERGIN+y,MAP_INFO_TEAMBASE)
				;if DEBUG_MODE : logmes "D x,y,t="+x+","+y+","+t
				color team_info(t,COLOR_R),team_info(t,COLOR_G),team_info(t,COLOR_B)
				boxf x*32+10, y*32+10, x*32+22, y*32+22
			}
		next
	next
	

	; キャラ情報
	color 255,255,255

	; 主人公
	es_pos char_spid(0,1), 5,330 ; アイコン
	color 255,255,255
	pos 40,330
	mes char_desc(0,0) ; 名前
	mes strf("HP: %3d / %3d",char_info(0,CHAR_INFO_HP) ,char_info(0,CHAR_INFO_MAXHP) ) ; HP
	color 192,0,0
	boxf 40,354,40+80,357 ; 最大HP
	barlength = char_info(0,CHAR_INFO_HP) * 80 / char_info(0,CHAR_INFO_MAXHP)
	color 0,192,0
	boxf 40,354,40+barlength,357 ; 現在HP
	
	color 255,255,255
	pos 40,360
	mes strf("WP: %3d / %3d",char_info(0,CHAR_INFO_WP) ,char_info(0,CHAR_INFO_MAXWP) ) ; WP
	color 128,128,128
	boxf 40,372,40+80,375 ; 最大WP
	barlength = char_info(0,CHAR_INFO_WP) * 80 / char_info(0,CHAR_INFO_MAXWP)
	color 64,64,192
	boxf 40,372,40+barlength,375 ; 現在WP
	
	; 武器の状態
	color 255,255,255
	pos  40,382 : mes "z"
	pos  70,382 : mes "x"
	pos 100,382 : mes "c"
	
	color 64,64,64
	boxf  40,382, 40+20,385 ; 武器1
	boxf  70,382, 70+20,385 ; 武器2
	boxf 100,382,100+20,385 ; 武器3

	perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON1),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON1HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON1),WEAPON_INFO_COOLDOWN)
	if perc = 20 {
		color 64,64,255
	} else {
		color 128,128,224
	}
	boxf  40,382, 40+perc,385 ; 武器1
	
	perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON2),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON2HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON2),WEAPON_INFO_COOLDOWN)
	if perc = 20 {
		color 64,64,255
	} else {
		color 128,128,224
	}
	boxf  70,382, 70+perc,385 ; 武器2
	
	perc = ( weapon_info(char_info(0,CHAR_INFO_WEAPON3),WEAPON_INFO_COOLDOWN) - char_info(0,CHAR_INFO_WEAPON3HEAT) ) * 20 / weapon_info(char_info(0,CHAR_INFO_WEAPON3),WEAPON_INFO_COOLDOWN)
	if perc = 20 {
		color 64,64,255
	} else {
		color 128,128,224
	}
	boxf 100,382,100+perc,385 ; 武器3
	
	; 敵キャラ
	if char_info(1,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(1,1), 180,330 ; アイコン
		color 255,255,255
		pos 215,330
		mes char_desc(1,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(1,CHAR_INFO_HP) ,char_info(1,CHAR_INFO_MAXHP) ) ; HP
		color 192,0,0
		boxf 215,354,215+80,357 ; 最大HP
		barlength = char_info(1,CHAR_INFO_HP) * 80 / char_info(1,CHAR_INFO_MAXHP)
		color 0,192,0
		boxf 215,354,215+barlength,357 ; 現在HP
	
		color 255,255,255
		pos 215,360 
		mes strf("WP: %3d / %3d",char_info(1,CHAR_INFO_WP) ,char_info(1,CHAR_INFO_MAXWP) ) ; WP
		color 128,128,128
		boxf 215,372,215+80,375 ; 最大WP
		barlength = char_info(1,CHAR_INFO_WP) * 80 / char_info(1,CHAR_INFO_MAXWP)
		color 64,64,192
		boxf 215,372,215+barlength,375 ; 現在WP
	}
	if char_info(2,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(2,1), 180,380 ; アイコン
		color 255,255,255
		pos 215,380
		mes char_desc(2,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(2,CHAR_INFO_HP) ,char_info(2,CHAR_INFO_MAXHP) ) ; HP
		color 192,0,0
		boxf 215,404,215+80,407 ; 最大HP
		barlength = char_info(2,CHAR_INFO_HP) * 80 / char_info(2,CHAR_INFO_MAXHP)
		color 0,192,0
		boxf 215,404,215+barlength,407 ; 現在HP
	
		color 255,255,255
		pos 215,410 
		mes strf("WP: %3d / %3d",char_info(2,CHAR_INFO_WP) ,char_info(2,CHAR_INFO_MAXWP) ) ; WP
		color 128,128,128
		boxf 215,422,215+80,425 ; 最大WP
		barlength = char_info(2,CHAR_INFO_WP) * 80 / char_info(2,CHAR_INFO_MAXWP)
		color 64,64,192
		boxf 215,422,215+barlength,425 ; 現在WP
	}
	if char_info(3,CHAR_INFO_ACTIVE) = 1 {
		es_pos char_spid(3,1), 180,430 ; アイコン
		color 255,255,255
		pos 215,430
		mes char_desc(3,0) ; 名前
		mes strf("HP: %3d / %3d",char_info(3,CHAR_INFO_HP) ,char_info(3,CHAR_INFO_MAXHP) ) ; HP
		color 192,0,0
		boxf 215,454,215+80,457 ; 最大HP
		barlength = char_info(3,CHAR_INFO_HP) * 80 / char_info(3,CHAR_INFO_MAXHP)
		color 0,192,0
		boxf 215,454,215+barlength,457 ; 現在HP
	
		color 255,255,255
		pos 215,460 
		mes strf("WP: %3d / %3d",char_info(3,CHAR_INFO_WP) ,char_info(3,CHAR_INFO_MAXWP) ) ; WP
		color 128,128,128
		boxf 215,472,215+80,475 ; 最大WP
		barlength = char_info(3,CHAR_INFO_WP) * 80 / char_info(3,CHAR_INFO_MAXWP)
		color 64,64,192
		boxf 215,472,215+barlength,475 ; 現在WP
	}	
	; 全体の色蓄積情報

	dim perc,TEAM_MAX
	if map_bucket_globalsum > 0 {
		for i,0,TEAM_MAX
			perc(i) = map_bucket_sum(i) * 300 / map_bucket_globalsum
		next
	}

	color 64,64,64
	boxf 10,323,10+300,327
	point = 0
	for i,0,TEAM_MAX
		color team_info(i,COLOR_R),team_info(i,COLOR_G),team_info(i,COLOR_B)
		boxf 10+point,323,10+point+perc(i),327
		point += perc(i)
	next
	
	return

; スプライトの表示位置計算
*spplot
	; キャラクタの表示位置計算
	for i,0,CHAR_MAX
		if char_spid(i,0)!0 {
			char_sppos(i,CIE_X) = (char_mappos(i,CIE_X)-MAP_MERGIN)*32
			char_sppos(i,CIE_Y) = (char_mappos(i,CIE_Y)-MAP_MERGIN)*32
		}
	next
	; 弾丸の表示位置計算
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			bullet_sppos(i,CIE_X) = (bullet_mappos(i,CIE_X)-MAP_MERGIN)*32
			bullet_sppos(i,CIE_Y) = (bullet_mappos(i,CIE_Y)-MAP_MERGIN)*32
		}
	next
	return

; スプライトの位置反映
*sppos
	; キャラクタの表示位置反映
	for i,0,CHAR_MAX
		if char_spid(i,0)!0 {
			es_pos char_spid(i),char_sppos(i,CIE_X),char_sppos(i,CIE_Y) ; スプライトの画面表示位置について保持情報を反映
		}
	next
	; 弾丸の表示位置反映
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			es_pos bullet_spid(i),bullet_sppos(i,CIE_X),bullet_sppos(i,CIE_Y) ; スプライトの画面表示位置について保持情報を反映
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN ){ ; 弾丸を下向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_DOWN
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT ){ ; 弾丸を左向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_LEFT
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP ){ ; 弾丸を上向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_UP
			}
			if ( bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT ){ ; 弾丸を右向きに変更
				es_setrot bullet_spid(i),SPCHAR_BULLET_DIREC_RIGHT
			}
		}
	next
	return

; 入力キー確認 
*checkinput
	; キー入力を処理
	dim rest,5
	getkey rest(0),37 ; カーソルキー[←]
	getkey rest(1),38 ; カーソルキー[↑]
	getkey rest(2),39 ; カーソルキー[→]
	getkey rest(3),40 ; カーソルキー[↓]

	getkey rest(4),90 ; zキー
	getkey rest(5),88 ; xキー
	getkey rest(6),67 ; cキー
	

	; キー入力を処理（ゆくゆくは行動の処理に移管）
	if rest(0)=1 {	; 左を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_LEFT
	}
	if rest(1)=1 {	; 上を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_UP
	}
	if rest(2)=1 {	; 右を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT
	}
	if rest(3)=1 {	; 下を検知
		char_info(0,CHAR_INFO_NEXTMOVE) = DIREC_DOWN
	}
	if rest(6)=1 {	; cキーを検知
		char_info(0,CHAR_INFO_NEXTACT) = 3
	} else {
		if rest(5)=1 {	; xキーを検知
			char_info(0,CHAR_INFO_NEXTACT) = 2
		} else {
			if rest(4)=1 {	; zキーを検知
				char_info(0,CHAR_INFO_NEXTACT) = 1
			}
		}
	}

	return

; 主人公以外の行動の決定
*comthink
	getreq record_comthink(0,0),SYSREQ_TIMER
	for i,0,CHAR_MAX
		getreq record_comthink(i+1,0),SYSREQ_TIMER
		for j,1,8
			record_comthink(i+1,j) = record_comthink(i+1,0)
		next
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue						; 有効でない場合は何もしない
		if DEBUG_MODE : logmes "I call *comthink charid="+i+", CTRLMODE="+char_info(i,CHAR_INFO_CTRLMODE)
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_MANUAL : _continue	; MANUALの場合は何もしない
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_NOACT : _continue	; NOACTの場合は何もしない
		if ( char_info(i,CHAR_INFO_MOVEHEAT) > 0 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) > 0 ) : _continue	; 行動、武器1がクールダウンタイム中なら何もしない

		getreq record_comthink(i+1,1),SYSREQ_TIMER ; 無視判定まで
		
		x = char_mappos(i,CIE_X)
		y = char_mappos(i,CIE_Y)
		
		; CHAR_CTRLMODE_RANDOMの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_RANDOM {
			if DEBUG_MODE : logmes "D ランダムモード charid="+i

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐

			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 4
			gosub *sub_calc_map_steps
			
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+x+","+y+", 足元の認識="+map_steps_info(x,y)

			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成

			; 足元が色蓄積がない、ほぼない（50以下）の場合
			if map_steps_info(x,y)&MAP_STEPS_INFO_NOCOLOR {
				; 60%の確率で武器1を使う
				if rnd(100) < 60 {
					char_info(i,CHAR_INFO_NEXTACT) = 1
					if DEBUG_MODE : logmes "D 武器1を使う charid="+i
				}
			}

			getreq record_comthink(i+1,4),SYSREQ_TIMER ; NOCOLOR判断

			; 足元が敵チームの色（十分塗られている、50より多い）の場合
			if map_steps_info(x,y)&MAP_STEPS_INFO_ENEMYCOLOR {
				; 80%の確率で武器1を使う
				if rnd(100) < 80 {
					char_info(i,CHAR_INFO_NEXTACT) = 1
					if DEBUG_MODE : logmes "D 武器1を使う charid="+i
				}
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; ENEMYCOLOR判断
			
			; 足元が自チームの色（十分塗られている、50より多い）の場合
			if map_steps_info(x,y)&MAP_STEPS_INFO_ALLYCOLOR {
				; 80%の確率で移動する
				if rnd(100) < 80 {
					; 60%の確率で向いている方向に移動する
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; MAP_STEPS_INFO_ALLYCOLOR判断
			
		}
		; CHAR_CTRLMODE_NOMOVEの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_NOMOVE {

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐

			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = x
			sub_calc_map_steps_posy = y
			sub_calc_map_steps_flag = 4
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+x+","+y+", 足元の認識="+map_steps_info(x,y)

			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 50%の確率で向きを変える
			if rnd(100) < 50 {
				if map_steps_canmove_cnt > 0 {
					direc = map_steps_canmove(rnd(map_steps_canmove_cnt))
					if direc ! char_info(i,CHAR_INFO_DIREC) : char_info(i,CHAR_INFO_NEXTMOVE) = direc
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 向き変更判定
			
			; 70%の確率で武器1を使う
			if rnd(100) < 70 {
				char_info(i,CHAR_INFO_NEXTACT) = 1
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; 攻撃判定
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; 
			
		}
		; CHAR_CTRLMODE_PAINTERの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_PAINTER {

			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐
			
			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = char_mappos(i,CIE_X)
			sub_calc_map_steps_posy = char_mappos(i,CIE_Y)
			sub_calc_map_steps_flag = 5
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+char_mappos(i,CIE_X)+","+char_mappos(i,CIE_Y)+", 足元の認識="+map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))
			
			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 移動先は最寄りの色が塗れる場所
			if map_steps_nocolormove_cnt > 0 {
				char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_nocolormove(rnd(map_steps_nocolormove_cnt))
			} else {
				; 90%の確率で移動する
				if rnd(100) < 90 {
					; 70%の確率で向いている方向に移動する
					if rnd(100) < 70 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 移動先判定
			
			; 足元が色蓄積がない、ほぼない（50以下）の場合
			if map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))&MAP_STEPS_INFO_NOCOLOR {
				; 90%の確率で武器1を使う
				if rnd(100) < 90 {
					char_info(i,CHAR_INFO_NEXTACT) = 1
					if DEBUG_MODE : logmes "D 武器1を使う charid="+i
				}
			}
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; NOCOLOR判定
			
			; 足元が敵チームの色（十分塗られている、50より多い）の場合
			if map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))&MAP_STEPS_INFO_ENEMYCOLOR {
				; 95%の確率で武器1を使う
				if rnd(100) < 95 {
					char_info(i,CHAR_INFO_NEXTACT) = 1
					if DEBUG_MODE : logmes "D 武器1を使う charid="+i
				}
			}			
			
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; ENEMYCOLOR判定
			
		}
		; CHAR_CTRLMODE_ATTACKERの場合
		if char_info(i,CHAR_INFO_CTRLMODE) = CHAR_CTRLMODE_ATTACKER {
			
			getreq record_comthink(i+1,2),SYSREQ_TIMER ; モード分岐
			
			; そのキャラが認識するマップの作成
			sub_calc_map_steps_posx = char_mappos(i,CIE_X)
			sub_calc_map_steps_posy = char_mappos(i,CIE_Y)
			sub_calc_map_steps_flag = 2
			gosub *sub_calc_map_steps
			if DEBUG_MODE : logmes "D 行動の思考 charid="+i+"("+char_desc(i,0)+"), 座標="+char_mappos(i,CIE_X)+","+char_mappos(i,CIE_Y)+", 足元の認識="+map_steps_info(char_mappos(i,CIE_X),char_mappos(i,CIE_Y))
			
			getreq record_comthink(i+1,3),SYSREQ_TIMER ; マップ作成
			
			; 移動先は主人公へ
			if map_steps_enemymove_cnt > 0 {
				char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_enemymove(rnd(map_steps_enemymove_cnt))
				if DEBUG_MODE : logmes "D 行動の思考 移動先は主人公へ"
			} else {
				; 60%の確率で移動する
				if rnd(100) < 60 {
					; 60%の確率で向いている方向に移動する
					if rnd(100) < 60 {
						char_info(i,CHAR_INFO_NEXTMOVE) = char_info(i,CHAR_INFO_DIREC)
					}
					else {
						; ランダムに向きを変える（向きを変えない可能性もあり）
						if map_steps_canmove_cnt > 0 {
							char_info(i,CHAR_INFO_NEXTMOVE) = map_steps_canmove(rnd(map_steps_canmove_cnt))
						}
					}
				}
			}
			
			getreq record_comthink(i+1,4),SYSREQ_TIMER ; 移動先判定
			
			; 60%の確率で武器1を使う
			if rnd(100) < 60 {
				char_info(i,CHAR_INFO_NEXTACT) = 1
				if DEBUG_MODE : logmes "D 武器1を使う charid="+i
			}			
			
			getreq record_comthink(i+1,5),SYSREQ_TIMER ; 武器判定
			getreq record_comthink(i+1,6),SYSREQ_TIMER ; 
			
		}
		getreq record_comthink(i+1,7),SYSREQ_TIMER
	next

	; 処理時間の計算
	for i,0,CHAR_MAX
		rangetime_comthink(i,0) = record_comthink(i+1,7) - record_comthink(i+1,0)
		for j,0,8-1
			rangetime_comthink(i,j+1) = record_comthink(i+1,j+1) - record_comthink(i+1,j)
		next
	next
	; 処理時間のロギング
	for i,0,CHAR_MAX
		if DEBUG_MODE : logmes strf("D charid=%d : time=%s(%s,%s,%s,%s,%s,%s,%s)",i,rangetime_comthink(i,0),rangetime_comthink(i,1),rangetime_comthink(i,2),rangetime_comthink(i,3),rangetime_comthink(i,4),rangetime_comthink(i,5),rangetime_comthink(i,6),rangetime_comthink(i,7) )
	next
	
	return

; 行動の処理
*execact
	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない
		if char_info(i,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしてたら何もしない
		; 通常攻撃を処理
		if ( char_info(i,CHAR_INFO_NEXTACT) = 1 ) and ( char_info(i,CHAR_INFO_WEAPON1HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON1), WEAPON_INFO_COSTWP) {
				; 1番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON1)
				gosub *sub_create_bullet
				
				char_info(i,CHAR_INFO_WEAPON1HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON1), WEAPON_INFO_COOLDOWN)
			}
		}
		if ( char_info(i,CHAR_INFO_NEXTACT) = 2 ) and ( char_info(i,CHAR_INFO_WEAPON2HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON2), WEAPON_INFO_COSTWP) {
				; 2番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON2)
				gosub *sub_create_bullet
				
				char_info(i,CHAR_INFO_WEAPON2HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON2), WEAPON_INFO_COOLDOWN)
			}
		}
		if ( char_info(i,CHAR_INFO_NEXTACT) = 3 ) and ( char_info(i,CHAR_INFO_WEAPON3HEAT) <= 0 ) {
			if char_info(i,CHAR_INFO_WP) >= weapon_info(char_info(i,CHAR_INFO_WEAPON3), WEAPON_INFO_COSTWP) {
				; 3番目の武器で弾丸を生成する
				sub_create_bullet_charid = i
				sub_create_bullet_weaponid = char_info(i,CHAR_INFO_WEAPON3)
				gosub *sub_create_bullet
				
				char_info(i,CHAR_INFO_WEAPON3HEAT) = weapon_info(char_info(i,CHAR_INFO_WEAPON3), WEAPON_INFO_COOLDOWN)
			}
		}
		; 移動を処理
		if ( char_info(i,CHAR_INFO_NEXTMOVE) ! DIREC_NONE ) and ( char_info(i,CHAR_INFO_MOVEHEAT) <= 0 ) {
			flag_move = 1
			; 移動先を afterx, afteryに入れる
			afterx = char_mappos(i,CIE_X)
			aftery = char_mappos(i,CIE_Y)
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_LEFT  ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_LEFT  ) : afterx -= 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_UP    ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_UP    ) : aftery -= 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_RIGHT ) : afterx += 1
			if ( char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_DOWN  ) and ( char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN  ) : aftery += 1

			; 侵入不可マスなら移動しない
			if map_info(afterx, aftery, MAP_INFO_TYPE) = MAP_TYPE_IMPOSSIBLE {
				flag_move = 0
			}
			for j,0,CHAR_MAX
				if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は無視する
				if char_info(j,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしてたら無視する
				if i = j : _continue								; 自分だったら無視する
				; 既にキャラがいたら移動しない
				if ( char_mappos(j,CIE_X) = afterx ) and ( char_mappos(j,CIE_Y) = aftery ) {
					flag_move = 0
				}
			next
			
			; 移動の成功失敗を問わず、向きの設定とスプライトの向きを変える
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_LEFT {
				char_info(i,CHAR_INFO_DIREC) = DIREC_LEFT
				es_chr char_spid(i,0),char_spcharid(i,DIREC_LEFT) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_UP {
				char_info(i,CHAR_INFO_DIREC) = DIREC_UP
				es_chr char_spid(i,0),char_spcharid(i,DIREC_UP) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_RIGHT {
				char_info(i,CHAR_INFO_DIREC) = DIREC_RIGHT
				es_chr char_spid(i,0),char_spcharid(i,DIREC_RIGHT) ; スプライトの向きを変更
			}
			if char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_DOWN {
				char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
				es_chr char_spid(i,0),char_spcharid(i,DIREC_DOWN) ; スプライトの向きを変更
			}
			
			if flag_move = 1 {
				; 移動可能なのでキャラを移動する
				char_mappos(i,CIE_X) = afterx
				char_mappos(i,CIE_Y) = aftery
				; 移動出来たらクールダウンタイムを設定
				char_info(i,CHAR_INFO_MOVEHEAT) = char_info(i,CHAR_INFO_MOVEFREQ)
			}
		}

		; 実行の有無を問わず次の移動・行動は削除（先行入力した分を予期せず動作してしまうため）
		char_info(i,CHAR_INFO_NEXTMOVE) = DIREC_NONE
		char_info(i,CHAR_INFO_NEXTACT) = 0
		; 全てのクールダウンタイムの減少
		if char_info(i,CHAR_INFO_MOVEHEAT) > 0    : char_info(i,CHAR_INFO_MOVEHEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON1HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON1HEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON2HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON2HEAT) -= 1
		if char_info(i,CHAR_INFO_WEAPON3HEAT) > 0 : char_info(i,CHAR_INFO_WEAPON3HEAT) -= 1
		
		; キャラクタの位置が場所の上限を超えたら調整
		if char_mappos(i,CIE_X)<0 : char_mappos(i,CIE_X)=0
		if char_mappos(i,CIE_Y)<0 : char_mappos(i,CIE_Y)=0
		if char_mappos(i,CIE_X)>MAP_X : char_mappos(i,CIE_X)=MAP_X
		if char_mappos(i,CIE_Y)>MAP_Y : char_mappos(i,CIE_Y)=MAP_Y

	next
	
	return
	
; 弾丸の処理
*execbullet
	for i,0,BULLET_MAX
		if bullet_info(i,BULLET_INFO_ACTIVE)=1 {
			if DEBUG_MODE : logmes "I 弾丸の処理開始 bullet id="+i
			flag_move = 0
			flag_hit = 0
			dim hit_char,CHAR_MAX
			hit_char_cnt = 0
			flag_spread = 0
			flag_delete = 0

			; 移動可能かどうか判定（移動しない弾丸は判定しない）
			if ( bullet_info(i,BULLET_INFO_SPPED) > 0 ) and ( bullet_info(i,BULLET_INFO_NOWSPREAD) = 0 )  {
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN {
					if map_info(bullet_mappos(i,CIE_X)  , bullet_mappos(i,CIE_Y)+1) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は下に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT {
					if map_info(bullet_mappos(i,CIE_X)-1, bullet_mappos(i,CIE_Y)  ) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は左に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP {
					if map_info(bullet_mappos(i,CIE_X)  , bullet_mappos(i,CIE_Y)-1) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は上に移動可能 bullet id="+i
					}
				}
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT {
					if map_info(bullet_mappos(i,CIE_X)+1, bullet_mappos(i,CIE_Y)  ) ! MAP_TYPE_IMPOSSIBLE {
						flag_move = 1
						if DEBUG_MODE : logmes "D 弾丸は右に移動可能 bullet id="+i
					}
				}
			}
			
			; 命中の判定
			if bullet_info(i,BULLET_INFO_RESTHIT) > 0{ ; HIT数が残っている
				for j,0,CHAR_MAX
					if ( char_info(j,CHAR_INFO_ACTIVE) = 1 ) and ( char_info(j,CHAR_INFO_DOWN) = 0 ) {
						if char_mappos(j,CIE_X) = bullet_mappos(i,CIE_X) and char_mappos(j,CIE_Y) = bullet_mappos(i,CIE_Y) { ; キャラと座標が一致
							if bullet_info(i,BULLET_INFO_TEAM) ! char_info(j,CHAR_INFO_TEAM) { ; 弾丸とキャラのチームが異なれば命中
								flag_hit = 1
								hit_char(hit_char_cnt) = j
								hit_char_cnt += 1
								if DEBUG_MODE : logmes "D 弾丸は命中判定 bullet id="+i
							}
						}
					}
				next
			}
			; 拡散、消滅の判定
			;;RESTRANGEが0、AUTOSPREADが1のため拡散
			if ( bullet_info(i,BULLET_INFO_RESTRANGE) <= 0 ) and ( bullet_info(i,BULLET_INFO_AUTOSPREAD) = 1 ) {
				flag_spread = 1
				if DEBUG_MODE : logmes "D 弾丸は拡散判定 bullet id="+i
			}
			;;RESTRANGEが0、AUTOSPREADが0のため消滅
			if ( bullet_info(i,BULLET_INFO_RESTRANGE) <= 0 ) and ( bullet_info(i,BULLET_INFO_AUTOSPREAD) = 0 ) {
				flag_delete = 1
				if DEBUG_MODE : logmes "D 弾丸は消滅判定 bullet id="+i
			}
			; ; 拡散持続の判定（あとで実装）
			if ( bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 ) and ( bullet_info(i,BULLET_INFO_RESTSPREAD) > 0 ) {
				flag_spread = 1
				if DEBUG_MODE : logmes "D 弾丸は拡散判定(継続) bullet id="+i
			}
			; 命中、拡散の実行
			if ( flag_hit = 1 ) or ( flag_spread = 1 ) {

				; 命中音を鳴らす
				if bullet_info(i,BULLET_INFO_SOUND_HIT) > 0 {
					mmplay bullet_info(i,BULLET_INFO_SOUND_HIT)	; 命中の効果音
				}
				
				bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 ; 拡散状態にする
				sub_calc_map_steps_posx = bullet_mappos(i,CIE_X)
				sub_calc_map_steps_posy = bullet_mappos(i,CIE_Y)
				sub_calc_map_steps_flag = 0
				gosub *sub_calc_map_steps
				for r,0,bullet_info(i,BULLET_INFO_SPREAD)+1 ; 0からSPREADまで処理(for文の終値は含まないなので+1)
					for y,0,MAP_Y ; 効率は悪いが震源地から順番に処理していく 
						for x,0,MAP_X
							if map_steps(x,y) = r { ; 命中、拡散の処理をするマス
								weaken = 100 ; 減衰率
								for w,0,r ; r=0の時は何もしない、r=1の時は1回掛け算、r=2の時は2回掛け算
									weaken = weaken * bullet_info(i,BULLET_INFO_WEAKEN) / 100
								next
								; キャラへのダメージ処理
								for j,0,CHAR_MAX
									if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; アクティブでなければ無視
									if char_info(j,CHAR_INFO_DOWN) = 1 : _continue		; ダウンしていたら無視
									if bullet_info(i,BULLET_INFO_TEAM) = char_info(j,CHAR_INFO_TEAM) : _continue	; 自チームの弾丸は判定しない
									
									if ( char_mappos(j,CIE_X) = x ) and ( char_mappos(j,CIE_Y) = y ) {
										damage = bullet_info(i,BULLET_INFO_ATC) * weaken / 100 - char_info(j,CHAR_INFO_DEF)
										if damage > 0 {
											char_info(j,CHAR_INFO_DAMAGE) += damage
										}
										else { ; 最低でも1ダメージは入る
											char_info(j,CHAR_INFO_DAMAGE) += 1
										}
									}
								next
								; 色蓄積
								; 弾丸のTEAM色に 色蓄積力（対バケツ）× 減衰率 分蓄積する
								map_bucket(x,y,bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORPOWER) * weaken / 100
								if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+x+", y="+y+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORPOWER) * weaken / 100

							}
						next
					next
				next

				; 弾丸を消去（拡散状態を継続できない場合）
				if bullet_info(i,BULLET_INFO_RESTSPREAD) <= 0 {
					sub_delete_bullet_bulletid = i
					gosub *sub_delete_bullet
					if DEBUG_MODE : logmes "D 弾丸は消去 bullet id="+i
					_break ; 次の弾丸の処理に移動
				}
			}
			; 消滅の実行
			if flag_delete = 1 {
				if bullet_info(i,BULLET_INFO_COLORFLY) > 0 {
					; 消滅時も飛翔時の色蓄積は実行する
					map_bucket(bullet_mappos(i,CIE_X),bullet_mappos(i,CIE_Y),bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORFLY)
					if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+bullet_mappos(i,CIE_X)+", y="+bullet_mappos(i,CIE_Y)+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORFLY)
				}
				; 弾丸を消去
				sub_delete_bullet_bulletid = i
				gosub *sub_delete_bullet
				if DEBUG_MODE : logmes "D 弾丸は消去 bullet id="+i
				_break ; 次の弾丸の処理に移動
			}
			; 飛翔時の色蓄積の実行
			if bullet_info(i,BULLET_INFO_COLORFLY) > 0 {
				map_bucket(bullet_mappos(i,CIE_X),bullet_mappos(i,CIE_Y),bullet_info(i,BULLET_INFO_TEAM)) += bullet_info(i,BULLET_INFO_COLORFLY)
				if DEBUG_MODE : logmes "D 弾丸は色蓄積を実行 bullet id="+i+", x="+bullet_mappos(i,CIE_X)+", y="+bullet_mappos(i,CIE_Y)+", 蓄積力="+ bullet_info(i,BULLET_INFO_COLORFLY)
			}
			; 移動の実行
			if flag_move = 1 {
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_DOWN  : bullet_mappos(i,CIE_Y) += 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_LEFT  : bullet_mappos(i,CIE_X) -= 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_UP    : bullet_mappos(i,CIE_Y) -= 1
				if bullet_info(i,BULLET_INFO_DIREC) = DIREC_RIGHT : bullet_mappos(i,CIE_X) += 1
				if DEBUG_MODE : logmes "D 弾丸の移動を実行 bullet id="+i
			}
			; RESTRANGE, RESTSPREADの減少
			bullet_info(i,BULLET_INFO_RESTRANGE) -= 1
			if bullet_info(i,BULLET_INFO_NOWSPREAD) = 1 {
				bullet_info(i,BULLET_INFO_RESTSPREAD) -= 1
			}
			if DEBUG_MODE : logmes "I 弾丸の処理を終了 bullet id="+i+", RESTRANGE="+bullet_info(i,BULLET_INFO_RESTRANGE)+", RESTSPREAD="+bullet_info(i,BULLET_INFO_RESTSPREAD)
		}
	next
	
	return

; 色蓄積の計算
*culcbucket
	
	dim map_bucket_sum,TEAM_MAX	; 全体の累積の色蓄積を初期化
	for x,0,MAP_X
		for y,0,MAP_Y
			sum = 0
			sumc = 0
			max = 0
			maxt = -1
			for z,0,TEAM_MAX
				if map_bucket(x,y,z) > 0 {
					map_bucket_sum(z) += map_bucket(x,y,z)
					sum += map_bucket(x,y,z)
					sumc += 1
					if map_bucket(x,y,z) > max {
						max = map_bucket(x,y,z)
						maxt = z
					}
				}
			next
			; 全体の色蓄積を計算
			map_bucket_globalsum = 0
			for z,0,TEAM_MAX
				map_bucket_globalsum += map_bucket_sum(z)
			next
			; 1マスに合計で100を超えた場合は超えた分だけ各チームの色蓄積を減算（端数の都合で減算後に100を超える場合もあるが気にしない）
			if sum > 100{
				cut = (sum-100)/sumc
				for z,0,TEAM_MAX
					if map_bucket(x,y,z) > 0 : map_bucket(x,y,z) -= cut
				next
			}
			; 上限制御
			for z,0,TEAM_MAX
				if map_bucket(x,y,z) > 100 : map_bucket(x,y,z) = 100
				if map_bucket(x,y,z) <   0 : map_bucket(x,y,z) =   0
			next			
			; 最も色蓄積が多いチームをleadに設定
			if max > 0 {
				map_bucket_lead(x,y) = maxt
			} else {
				map_bucket_lead(x,y) = -1
			}
		next
	next
	
	return

; キャラへのダメージ処理
*execdamage
	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない
		; 現在ダウンしていない場合
		if char_info(i,CHAR_INFO_DOWN) = 0{
			; ダメージがあればHPに反映
			if char_info(i,CHAR_INFO_DAMAGE) {
				char_info(i,CHAR_INFO_HP) -= char_info(i,CHAR_INFO_DAMAGE)
				if char_info(i,CHAR_INFO_HP) < 0 : char_info(i,CHAR_INFO_HP) = 0
				char_info(i,CHAR_INFO_DAMAGE) = 0
			}
			; HPが0以下ならDOWN
			if char_info(i,CHAR_INFO_HP) <= 0 {
				char_info(i,CHAR_INFO_DOWN) = 1
				mmplay sound_def_mediabuffid(SOUND_DEF_DOWN)	; ダウンの効果音
				es_fade char_spid(i),ESSPF_BLINKWIPE2,30 ; スプライトはゆっくり点滅し消滅
				char_spid(i,0) = 0
				; リスポーン可能な場合
				if char_info(i,CHAR_INFO_RESTRESPAWN) > 0{
					char_info(i,CHAR_INFO_RESTDOWNTIME) = char_info(i,CHAR_INFO_DOWNTIME)
					char_info(i,CHAR_INFO_RESTRESPAWN) -= 1
				} else {
					; リスポーンできない場合はダウン時に消去
					char_info(i,CHAR_INFO_ACTIVE) = 0
				}
			}
		} else {
			; 既にダウンしている場合
			char_info(i,CHAR_INFO_RESTDOWNTIME) -= 1
			; リスポーンできる場合
			if char_info(i,CHAR_INFO_RESTDOWNTIME) <=0 {
				; 誰かがいたらリスポーンできない
				flag_respawn = 1
				for j,0,CHAR_MAX
					if char_info(j,CHAR_INFO_ACTIVE) = 0 : _continue	; アクティブでなければ無視
					if i = j : _continue	; 自キャラは無視
					if ( char_mappos(j,CIE_X) = char_basepos(i,CIE_X) ) and ( char_mappos(j,CIE_Y) = char_basepos(i,CIE_Y) ) {
						flag_respawn = 0
					}
				next
				if flag_respawn = 1 {
					; リスポーン処理（リスポーン地点に移動、全回復）
					char_mappos(i,CIE_X) = char_basepos(i,CIE_X)
					char_mappos(i,CIE_Y) = char_basepos(i,CIE_Y)
					char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
					char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP)
					char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP)
					char_info(i,CHAR_INFO_DAMAGE) = 0
					char_info(i,CHAR_INFO_DOWN) = 0
					mmplay sound_def_mediabuffid(SOUND_DEF_RESPAWN)	; リスポーンの効果音
					; スプライト再生成
					es_set SP_MAP+i,0,0,defchar_sp(char_info(i,CHAR_INFO_DEFINECHAR),DEFCHAR_SP_ANIME_DOWN),0 ; MAP上キャラ、アニメキャラ（下向き）
					char_spid(i,0) = SP_MAP+i
					
					; 復活時にリスポーン地点に弾丸発射
					if char_info(i,CHAR_INFO_RESPAWNWEAPON) >= 0 {
						sub_create_bullet_charid = i
						sub_create_bullet_weaponid = char_info(i,CHAR_INFO_RESPAWNWEAPON)
						gosub *sub_create_bullet
					}
				} else {
					; 不正処理になりそうなので、今は実装しない
					;; 誰かが塞いでいる場合は弾丸発射
					;if char_info(i,CHAR_INFO_RESPAWNWEAPON) >= 0 {
					;	char_mappos(i,CIE_X) = char_basepos(i,CIE_X)
					;	char_mappos(i,CIE_Y) = char_basepos(i,CIE_Y)
					;	char_info(i,CHAR_INFO_DIREC) = DIREC_DOWN
					;	sub_create_bullet_charid = i
					;	sub_create_bullet_weaponid = char_info(i,CHAR_INFO_RESPAWNWEAPON)
					;	gosub *sub_create_bullet
					;}						
				}
			}
		}
	next
	return

; 自然回復などの処理
*execheal
	if TIMES \ 10 ! 0 : return ; 10 TIMEに1度しか処理しない

	for i,0,CHAR_MAX
		if char_info(i,CHAR_INFO_ACTIVE) = 0 : _continue	; 有効でない場合は何もしない
		if char_info(i,CHAR_INFO_DOWN) = 1 : _continue	; ダウンしていれば何もしない
		
		if map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) = 0{ ; 自チームの色蓄積がなければスリップダメージ
			char_info(i,CHAR_INFO_HP) -= 1
		}
		if map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) > 0{ ; 自チームの色蓄積があれば自然回復
			if char_info(i,CHAR_INFO_HP) < char_info(i,CHAR_INFO_MAXHP){
				char_info(i,CHAR_INFO_HP) += map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) / 10
			}
			if char_info(i,CHAR_INFO_WP) < char_info(i,CHAR_INFO_MAXWP){
				char_info(i,CHAR_INFO_WP) += map_bucket(char_mappos(i,CIE_X), char_mappos(i,CIE_Y), char_info(i,CHAR_INFO_TEAM)) / 20 +5
			}
		}
		if char_info(i,CHAR_INFO_HP) > char_info(i,CHAR_INFO_MAXHP) : char_info(i,CHAR_INFO_HP) = char_info(i,CHAR_INFO_MAXHP)
		if char_info(i,CHAR_INFO_WP) > char_info(i,CHAR_INFO_MAXWP) : char_info(i,CHAR_INFO_WP) = char_info(i,CHAR_INFO_MAXWP)
	next
	return


