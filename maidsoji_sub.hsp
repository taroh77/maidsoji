	goto *end_sub_hsp ; gosubで呼び出す定義のみなので、実行せず一番下までジャンプ

	;---------------------------------------------------------------------------------
	; キャラクタIDと武器IDを指定して弾丸を生成し発射する
	;   引数: sub_create_bullet_charid キャラクタID
	;   引数: sub_create_bullet_weaponid 武器ID
	;---------------------------------------------------------------------------------
*sub_create_bullet
	getreq sub_create_bullet_starttime,SYSREQ_TIMER
	if DEBUG_MODE : logmes "I call *sub_create_bullet: sub_create_bullet_charid="+sub_create_bullet_charid+", sub_create_bullet_weaponid="+sub_create_bullet_weaponid
	if ( sub_create_bullet_charid < 0 ) or ( sub_create_bullet_weaponid < 0 ) {
		if DEBUG_MODE : logmes "W exec *sub_create_bullet: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_create_bullet_charid = -1
		sub_create_bullet_weaponid = -1
		return
	}
	sub_create_bullet_bulletid = -1

	; WPが足りなければ弾丸生成失敗
	if char_info(sub_create_bullet_charid,CHAR_INFO_WP) < weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COSTWP) * ( 100 - char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100 {
		if DEBUG_MODE : logmes "D exec *sub_create_bullet: WPが足りません"
		; 次に備えて引数は初期化
		sub_create_bullet_charid = -1
		sub_create_bullet_weaponid = -1
		return
	}

	; 弾丸発射の場合
	if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_BULLET {
		for sub_create_bullet_i,0,BULLET_MAX
			if bullet_info(sub_create_bullet_i,BULLET_INFO_ACTIVE) = 0{ ; 空きを見つける
				sub_create_bullet_bulletid = sub_create_bullet_i
				_break
			}
		next
		if sub_create_bullet_bulletid = -1{
			if DEBUG_MODE : logmes "W exec *sub_create_bullet: 弾丸情報に空きがありません。上限を引き上げてください。"
			; 弾丸情報に空きがなく生成失敗
			; 次に備えて引数は初期化
			sub_create_bullet_charid = -1
			sub_create_bullet_weaponid = -1
			return 
		}
	
		; 弾丸を有効にする
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ACTIVE) = 1
	
		; 弾丸情報を武器情報から取得する
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_HIT) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_HIT)					; 命中数（何回当たり判定があるか。1:単発弾、2以上:貫通弾、0:命中しない）　※0の場合はAUTOSPREAD=1にしないと意味がない
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTHIT) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_HIT)				; 残り命中数（あと何回当たり判定が残っているか）
		sub_create_bullet_tmprange = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_RANGE) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_RANGE)
		if sub_create_bullet_tmprange < 0 : sub_create_bullet_tmprange = 0		; 射程は0未満になっても大丈夫かもしれないが念のため
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RANGE) = sub_create_bullet_tmprange										; 射程（全部で何回移動できるか）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTRANGE) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RANGE)			; 残り射程（あと何回移動できるか）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_AUTOSPREAD) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_AUTOSPREAD)	; 1:残り射程が0になったら拡散、0:残り射程が0になったら消滅
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SPPED) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SPPED)				; 1 TIMEで何マス移動できるか　※通常は1を想定。0にすると移動しないが残り射程は減る（設置型爆弾のような存在）
		sub_create_bullet_buffatc = char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_ATC)
		if sub_create_bullet_buffatc < -100 : sub_create_bullet_buffatc = -100 ; 攻撃のバフ-100未満は-100に（そうしないとたぶん回復してしまう）
		if DEBUG_MODE : logmes strf("charid=%d buffatc=%d",sub_create_bullet_charid,char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_ATC))
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ATC) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ATC) * ( 100 + sub_create_bullet_buffatc ) / 100							; 攻撃力（対キャラ）
		sub_create_bullet_buffcolorpower = char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COLORPOWER)
		if sub_create_bullet_buffcolorpower < -100 : sub_create_bullet_buffcolorpower = -100 ; 色蓄積のバフ-100未満は-100に（そうしないとたぶん色が消える）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_COLORPOWER) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COLORPOWER) * ( 100 + sub_create_bullet_buffcolorpower ) / 100	; 色蓄積力（対バケツ）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_COLORFLY) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COLORFLY) * ( 100 + sub_create_bullet_buffcolorpower ) / 100		; 飛翔時（非命中時）の色蓄積力（対バケツ）
		sub_create_bullet_tmpspread = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SPREAD) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_SPREAD)
		if sub_create_bullet_tmpspread < 0 : sub_create_bullet_tmpspread = 0		; 拡散範囲は0未満になっても大丈夫かもしれないが念のため
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SPREAD) = sub_create_bullet_tmpspread			; 命中時の拡散範囲（0:着弾地点のみ、1以上:そのマスだけ拡散）
		sub_create_bullet_tmpweaken = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_WEAKEN) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_WEAKEN)
		if sub_create_bullet_tmpweaken <   0 : sub_create_bullet_tmpweaken = 0		; 減衰率は0未満にはしない
		if sub_create_bullet_tmpweaken > 100 : sub_create_bullet_tmpweaken = 100	; 減衰率は100より大きくしない
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_WEAKEN) = sub_create_bullet_tmpweaken			; 拡散時の威力減衰率（100: 減衰しない ⇔ 50: 1マス移動するごとに半減 ⇔ 0:ダメージや色蓄積がない）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_PERSIST) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_PERSIST)			; 拡散が持続するかどうか（0:持続しない、1以上:そのTIMEだけ持続）
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTSPREAD) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_PERSIST)		; あと何TIME拡散が持続するか
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATE) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATE)		; 追加で付与するステート
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATERATE) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATERATE)		; 追加でステートを付与する確率
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATETIME) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATETIME)		; ステートの効果時間
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SOUND_HIT) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_HIT)		; 命中時のサウンドID
		
		; パッシブスキル判定（攻撃時に自分が特定のステートだった場合、攻撃にステート付与）
		if char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_ATCADDSTATE) > 0 {
			sub_create_bullet_state_type = passive_info(char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_ATCADDSTATE),PASSIVE_INFO_VALUE1)
			; 特定のステートであれば発動
			if char_info(sub_create_bullet_charid,CHAR_INFO_STATEACTIVE_BEGIN+sub_create_bullet_state_type) > 0{
				bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATETIME) = passive_info(char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_ATCADDSTATE),PASSIVE_INFO_VALUE4)
				bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATE) = passive_info(char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_ATCADDSTATE),PASSIVE_INFO_VALUE5)
				bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATERATE) = 100
			}
		}
		; パッシブスキル判定（相手が特定のステートだった場合、ステート付与率を変える）
		if char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_STATEADDUP) > 0 {
			; パッシブスキルを弾丸に付与する
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_PASSIVE) = char_info(sub_create_bullet_charid,CHAR_INFO_PASSIVE_STATEADDUP)
		}
		
		; 弾丸の所属、位置、向きはキャラクタと一致させる
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_TEAM) = char_info(sub_create_bullet_charid,CHAR_INFO_TEAM)
		bullet_mappos(sub_create_bullet_bulletid,CIE_X) = char_mappos(sub_create_bullet_charid,CIE_X)
		bullet_mappos(sub_create_bullet_bulletid,CIE_Y) = char_mappos(sub_create_bullet_charid,CIE_Y)
		if DEBUG_MODE : logmes "D exec *sub_create_bullet: 弾丸の情報 データ座標="+bullet_mappos(sub_create_bullet_bulletid,CIE_X)+","+bullet_mappos(sub_create_bullet_bulletid,CIE_Y)
		bullet_info(sub_create_bullet_bulletid,BULLET_INFO_DIREC) = char_info(sub_create_bullet_charid,CHAR_INFO_DIREC)
	
		; 発射音を鳴らす
		if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE) > 0 {
			mmplay weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE)	; 発射の効果音
		}
	
		; 弾丸のスプライト生成（スプライトの座標は0,0で生成するので後で修正が必要）
		es_set SP_BULLET_STATIC+sub_create_bullet_bulletid,0,0,SPCHAR_BULLET_STATIC+weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_BULLETSPID),0,3
		bullet_spid(sub_create_bullet_bulletid) = SP_BULLET_STATIC+sub_create_bullet_bulletid
	
		; 弾丸を生成したのでWPを消費
		sub_create_bullet_costwp = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COSTWP) * ( 100 - char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100
		if sub_create_bullet_costwp <= 0 : sub_create_bullet_costwp = 1 ; 最低でも1消費 
		char_info(sub_create_bullet_charid,CHAR_INFO_WP) -= sub_create_bullet_costwp
	
		getreq sub_create_bullet_endtime,SYSREQ_TIMER
		sub_create_bullet_rangetime = sub_create_bullet_endtime - sub_create_bullet_starttime
		if DEBUG_MODE : logmes "I exec *sub_create_bullet: 弾丸を正常に生成しました sub_create_bullet_bulletid="+sub_create_bullet_bulletid+", time="+sub_create_bullet_rangetime
	}
	; 自分に直接効果ありの場合
	if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_SELF {
		; 確率でステートを付与
		if rnd(100) < weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATERATE){
			sub_set_state_charid=sub_create_bullet_charid
			sub_set_state_resttime=weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATETIME)
			sub_set_state_type=weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATE)
			gosub *sub_set_state
			; 発射音を鳴らす
			if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE) > 0 {
				mmplay weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE)	; 発射の効果音
			}
			; 弾丸を生成したのでWPを消費
			sub_create_bullet_costwp = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COSTWP) * ( 100 - char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100
			if sub_create_bullet_costwp <= 0 : sub_create_bullet_costwp = 1 ; 最低でも1消費 
			char_info(sub_create_bullet_charid,CHAR_INFO_WP) -= sub_create_bullet_costwp
		}
		getreq sub_create_bullet_endtime,SYSREQ_TIMER
		sub_create_bullet_rangetime = sub_create_bullet_endtime - sub_create_bullet_starttime
		if DEBUG_MODE : logmes "I exec *sub_create_bullet: 弾丸(自分に直接効果あり)を正常に生成しました time="+sub_create_bullet_rangetime
	}
	; 味方全員か敵全員に直接効果ありの場合
	if ( weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_ALLYALL ) or ( weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_ENEMYALL ) {
		for sub_create_bullet_i,0,CHAR_MAX
			; 味方全員に直接効果ありの場合
			if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_ALLYALL {
				if char_info(sub_create_bullet_i,CHAR_INFO_TEAM) != char_info(sub_create_bullet_charid,CHAR_INFO_TEAM) : _continue
			}
			; 敵全員に直接効果ありの場合
			if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_ENEMYALL {
				if char_info(sub_create_bullet_i,CHAR_INFO_TEAM) = char_info(sub_create_bullet_charid,CHAR_INFO_TEAM) : _continue
			}
			; 確率でステートを付与
			if rnd(100) < weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATERATE){
				sub_set_state_charid=sub_create_bullet_i
				sub_set_state_resttime=weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATETIME)
				sub_set_state_type=weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATE)
				gosub *sub_set_state
			}
		next
		; 発射音を鳴らす
		if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE) > 0 {
			mmplay weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE)	; 発射の効果音
		}
		; 弾丸を生成したのでWPを消費
		sub_create_bullet_costwp = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COSTWP) * ( 100 - char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100
		if sub_create_bullet_costwp <= 0 : sub_create_bullet_costwp = 1 ; 最低でも1消費 
		char_info(sub_create_bullet_charid,CHAR_INFO_WP) -= sub_create_bullet_costwp
		getreq sub_create_bullet_endtime,SYSREQ_TIMER
		sub_create_bullet_rangetime = sub_create_bullet_endtime - sub_create_bullet_starttime
		if DEBUG_MODE : logmes "I exec *sub_create_bullet: 弾丸(自分に直接効果あり)を正常に生成しました time="+sub_create_bullet_rangetime
	}
	; 4方向へ弾丸発射の場合
	if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_TYPE) = WEAPON_INFO_TYPE_4WAYBULLET {

		for sub_create_bullet_h,0,4
			for sub_create_bullet_i,0,BULLET_MAX
				if bullet_info(sub_create_bullet_i,BULLET_INFO_ACTIVE) = 0{ ; 空きを見つける
					sub_create_bullet_bulletid = sub_create_bullet_i
					_break
				}
			next
			if sub_create_bullet_bulletid = -1{
				if DEBUG_MODE : logmes "W exec *sub_create_bullet: 弾丸情報に空きがありません。上限を引き上げてください。"
				; 弾丸情報に空きがなく生成失敗
				; 次に備えて引数は初期化
				sub_create_bullet_charid = -1
				sub_create_bullet_weaponid = -1
				return 
			}
		
			; 弾丸を有効にする
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ACTIVE) = 1
		
			; 弾丸情報を武器情報から取得する
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_HIT) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_HIT)					; 命中数（何回当たり判定があるか。1:単発弾、2以上:貫通弾、0:命中しない）　※0の場合はAUTOSPREAD=1にしないと意味がない
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTHIT) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_HIT)				; 残り命中数（あと何回当たり判定が残っているか）
			sub_create_bullet_tmprange = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_RANGE) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_RANGE)
			if sub_create_bullet_tmprange < 0 : sub_create_bullet_tmprange = 0		; 射程は0未満になっても大丈夫かもしれないが念のため
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RANGE) = sub_create_bullet_tmprange										; 射程（全部で何回移動できるか）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTRANGE) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RANGE)			; 残り射程（あと何回移動できるか）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_AUTOSPREAD) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_AUTOSPREAD)	; 1:残り射程が0になったら拡散、0:残り射程が0になったら消滅
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SPPED) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SPPED)				; 1 TIMEで何マス移動できるか　※通常は1を想定。0にすると移動しないが残り射程は減る（設置型爆弾のような存在）
			sub_create_bullet_buffatc = char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_ATC)
			if sub_create_bullet_buffatc < -100 : sub_create_bullet_buffatc = -100 ; 攻撃のバフ-100未満は-100に（そうしないとたぶん回復してしまう）
			if DEBUG_MODE : logmes strf("charid=%d buffatc=%d",sub_create_bullet_charid,char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_ATC))
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ATC) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ATC) * ( 100 + sub_create_bullet_buffatc ) / 100							; 攻撃力（対キャラ）
			sub_create_bullet_buffcolorpower = char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COLORPOWER)
			if sub_create_bullet_buffcolorpower < -100 : sub_create_bullet_buffcolorpower = -100 ; 色蓄積のバフ-100未満は-100に（そうしないとたぶん色が消える）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_COLORPOWER) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COLORPOWER) * ( 100 + sub_create_bullet_buffcolorpower ) / 100	; 色蓄積力（対バケツ）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_COLORFLY) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COLORFLY) * ( 100 + sub_create_bullet_buffcolorpower ) / 100		; 飛翔時（非命中時）の色蓄積力（対バケツ）
			sub_create_bullet_tmpspread = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SPREAD) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_SPREAD)
			if sub_create_bullet_tmpspread < 0 : sub_create_bullet_tmpspread = 0		; 拡散範囲は0未満になっても大丈夫かもしれないが念のため
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SPREAD) = sub_create_bullet_tmpspread			; 命中時の拡散範囲（0:着弾地点のみ、1以上:そのマスだけ拡散）
			sub_create_bullet_tmpweaken = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_WEAKEN) + char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_WEAKEN)
			if sub_create_bullet_tmpweaken <   0 : sub_create_bullet_tmpweaken = 0		; 減衰率は0未満にはしない
			if sub_create_bullet_tmpweaken > 100 : sub_create_bullet_tmpweaken = 100	; 減衰率は100より大きくしない
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_WEAKEN) = sub_create_bullet_tmpweaken			; 拡散時の威力減衰率（100: 減衰しない ⇔ 50: 1マス移動するごとに半減 ⇔ 0:ダメージや色蓄積がない）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_PERSIST) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_PERSIST)			; 拡散が持続するかどうか（0:持続しない、1以上:そのTIMEだけ持続）
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_RESTSPREAD) = bullet_info(sub_create_bullet_bulletid,BULLET_INFO_PERSIST)		; あと何TIME拡散が持続するか
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATE) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATE)		; 追加で付与するステート
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATERATE) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATERATE)		; 追加でステートを付与する確率
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_ADDSTATETIME) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_ADDSTATETIME)		; ステートの効果時間
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_SOUND_HIT) = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_HIT)		; 命中時のサウンドID
		
			; 弾丸の所属、位置キャラクタと一致させる。向きは全方向。
			bullet_info(sub_create_bullet_bulletid,BULLET_INFO_TEAM) = char_info(sub_create_bullet_charid,CHAR_INFO_TEAM)
			bullet_mappos(sub_create_bullet_bulletid,CIE_X) = char_mappos(sub_create_bullet_charid,CIE_X)
			bullet_mappos(sub_create_bullet_bulletid,CIE_Y) = char_mappos(sub_create_bullet_charid,CIE_Y)
			if DEBUG_MODE : logmes "D exec *sub_create_bullet: 弾丸の情報 データ座標="+bullet_mappos(sub_create_bullet_bulletid,CIE_X)+","+bullet_mappos(sub_create_bullet_bulletid,CIE_Y)
			if sub_create_bullet_h = 0 : bullet_info(sub_create_bullet_bulletid,BULLET_INFO_DIREC) = DIREC_DOWN
			if sub_create_bullet_h = 1 : bullet_info(sub_create_bullet_bulletid,BULLET_INFO_DIREC) = DIREC_LEFT
			if sub_create_bullet_h = 2 : bullet_info(sub_create_bullet_bulletid,BULLET_INFO_DIREC) = DIREC_UP
			if sub_create_bullet_h = 3 : bullet_info(sub_create_bullet_bulletid,BULLET_INFO_DIREC) = DIREC_RIGHT

			; 弾丸のスプライト生成（スプライトの座標は0,0で生成するので後で修正が必要）
			es_set SP_BULLET_STATIC+sub_create_bullet_bulletid,0,0,SPCHAR_BULLET_STATIC+weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_BULLETSPID),0,3
			bullet_spid(sub_create_bullet_bulletid) = SP_BULLET_STATIC+sub_create_bullet_bulletid
		
			if DEBUG_MODE : logmes "I exec *sub_create_bullet: 弾丸を正常に生成しました sub_create_bullet_bulletid="+sub_create_bullet_bulletid+", time="+sub_create_bullet_rangetime
		next
		
		; 発射音を鳴らす
		if weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE) > 0 {
			mmplay weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_SOUND_FIRE)	; 発射の効果音
		}
		; 弾丸を生成したのでWPを消費
		sub_create_bullet_costwp = weapon_info(sub_create_bullet_weaponid,WEAPON_INFO_COSTWP) * ( 100 - char_info(sub_create_bullet_charid,CHAR_INFO_BUFFVALUE_COSTWP) ) / 100
		if sub_create_bullet_costwp <= 0 : sub_create_bullet_costwp = 1 ; 最低でも1消費 
		char_info(sub_create_bullet_charid,CHAR_INFO_WP) -= sub_create_bullet_costwp
		
		getreq sub_create_bullet_endtime,SYSREQ_TIMER
		sub_create_bullet_rangetime = sub_create_bullet_endtime - sub_create_bullet_starttime		
	}
	
	; 次に備えて引数は初期化
	sub_create_bullet_charid = -1
	sub_create_bullet_weaponid = -1
	return


	;---------------------------------------------------------------------------------
	; 弾丸を削除する
	;   引数: sub_delete_bullet_bulletid 弾丸ID
	;---------------------------------------------------------------------------------
*sub_delete_bullet
	getreq sub_delete_bullet_starttime,SYSREQ_TIMER
	if DEBUG_MODE : logmes "I call *sub_delete_bullet: bullet id="+sub_delete_bullet_bulletid
	if sub_delete_bullet_bulletid < 0 {
		if DEBUG_MODE : logmes "W exec *sub_delete_bullet: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_delete_bullet_bulletid = -1
		return
	}
	; スプライトの削除
	es_kill bullet_spid(sub_delete_bullet_bulletid)
	bullet_spid(sub_delete_bullet_bulletid) = 0

	; 座標の削除
	bullet_mappos(sub_delete_bullet_bulletid,CIE_X) = 0
	bullet_mappos(sub_delete_bullet_bulletid,CIE_Y) = 0
	bullet_sppos(sub_delete_bullet_bulletid,CIE_X) = 0
	bullet_sppos(sub_delete_bullet_bulletid,CIE_Y) = 0

	; 情報の削除
	for sub_delete_bullet_i,0,BULLET_INFO_MAX
		bullet_info(sub_delete_bullet_bulletid,sub_delete_bullet_i) = 0
	next
	
	getreq sub_delete_bullet_endtime,SYSREQ_TIMER
	sub_delete_bullet_rangetime = sub_delete_bullet_endtime - sub_delete_bullet_starttime
	if DEBUG_MODE : logmes "I exec *sub_delete_bullet: 弾丸を正常に削除しました sub_delete_bullet_bulletid="+sub_delete_bullet_bulletid+", time="+sub_delete_bullet_rangetime
	
	; 次に備えて引数は初期化
	sub_delete_bullet_bulletid = -1
	return
	

	;---------------------------------------------------------------------------------
	; 座標を指定して、その座標から各マスまで何マス移動すればたどり着くかをmap_stepsに入力する
	; 同時にmap_steps_infoにはそのマスの追加情報を入れる
	; map_steps_canmoveには直後に移動可能な方向を格納する
	;   引数: sub_calc_map_steps_posx X座標（データ座標系）
	;   引数: sub_calc_map_steps_posy Y座標（データ座標系）
	;   引数: sub_calc_map_steps_flag 拡張情報を取得する 0:取得しない 1:最寄りの塗れる場所 2:最寄りの敵 3:両方 4:敵のいる部分は侵入不可扱い 8:最寄りの自チームの床
	;---------------------------------------------------------------------------------
*sub_calc_map_steps
	sdim sub_calc_map_steps_rangetitle,32,8
	sub_calc_map_steps_rangetitle(0) = "指定ユニット特定","歩数マップ初期化","ユニットは侵入不可扱い","歩数マップの作成","追加info取得","flag1処理","flag2処理","flag8処理"
	dim sub_calc_map_steps_record,9
	dim sub_calc_map_steps_rangetime,8
	
	getreq sub_calc_map_steps_record(0),SYSREQ_TIMER
	if DEBUG_MODE : logmes "I call *sub_calc_map_steps: x="+sub_calc_map_steps_posx+", y="+sub_calc_map_steps_posy+", flag="+sub_calc_map_steps_flag
	if ( sub_calc_map_steps_posx < 0 ) or ( sub_calc_map_steps_posy < 0 )  or ( sub_calc_map_steps_flag < 0 ) {
		if DEBUG_MODE : logmes "W exec *sub_calc_map_steps: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_calc_map_steps_posx = -1
		sub_calc_map_steps_posy = -1
		return
	}

	if ( sub_calc_map_steps_flag & 2 ) and ( sub_calc_map_steps_flag & 4 ) {
		if DEBUG_MODE : logmes "W exec *sub_calc_map_steps: flag=2 と flag=4 は共存できません（実質flag=2が無効）"
	}

	; 指定した座標にユニットがいればmap_steps_infoにそのユニット視点で情報を入れる
	sub_calc_map_steps_team = -1
	for sub_calc_map_steps_i,0,CHAR_MAX
		if char_info(sub_calc_map_steps_i,CHAR_INFO_ACTIVE) = 1 {
			if char_mappos(sub_calc_map_steps_i,CIE_X) = sub_calc_map_steps_posx and char_mappos(sub_calc_map_steps_i,CIE_Y) = sub_calc_map_steps_posy {
				sub_calc_map_steps_team = char_info(sub_calc_map_steps_i,CHAR_INFO_TEAM)
				_break
			}
		}
	next

	getreq sub_calc_map_steps_record(1),SYSREQ_TIMER

	for sub_calc_map_steps_y,0,MAP_Y
		for sub_calc_map_steps_x,0,MAP_X
			map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) = 0 ; map_steps_infoを初期化
			; 侵入不可マスには -1 を入れる（map_steps）
			if map_info(sub_calc_map_steps_x,sub_calc_map_steps_y,MAP_INFO_TYPE) = MAP_TYPE_IMPOSSIBLE { 
				map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) = -1
			}
			; 未計算の部分には -2 を入れる（map_steps）
			if map_info(sub_calc_map_steps_x,sub_calc_map_steps_y,MAP_INFO_TYPE) = MAP_TYPE_NORMAL {
				map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) = -2 
			}
			; 指定座標にユニットがいれば追加情報を取得（map_steps_info）
			if sub_calc_map_steps_team >= 0 {
				for sub_calc_map_steps_i,0,TEAM_MAX
					if map_bucket(sub_calc_map_steps_x,sub_calc_map_steps_y,sub_calc_map_steps_i) > 50 {
						; 色が自チームで50より多く塗られている
						if sub_calc_map_steps_i = sub_calc_map_steps_team {
							map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) += MAP_STEPS_INFO_ALLYCOLOR
							;if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: "+sub_calc_map_steps_x+","+sub_calc_map_steps_y+"にMAP_STEPS_INFO_ALLYCOLORを設定"
						}
						; 色が敵チームで50より多く塗られている
						if sub_calc_map_steps_i ! sub_calc_map_steps_team {
							map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) += MAP_STEPS_INFO_ENEMYCOLOR
							;if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: "+sub_calc_map_steps_x+","+sub_calc_map_steps_y+"にMAP_STEPS_INFO_ENEMYCOLORを設定"
						}
					}
				next
				if ( map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_ALLYCOLOR ) or ( map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_ENEMYCOLOR ) {
					; いずれかの色が多く蓄積している
				}
				else {
					map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) += MAP_STEPS_INFO_NOCOLOR
					;if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: "+sub_calc_map_steps_x+","+sub_calc_map_steps_y+"にMAP_STEPS_INFO_NOCOLORを設定"
				}
			}
		next
	next

	getreq sub_calc_map_steps_record(2),SYSREQ_TIMER

	if sub_calc_map_steps_flag & 4 {
		; 自分以外がいるマスは侵入不可マスに
		for sub_calc_map_steps_i,0,CHAR_MAX
			if char_info(sub_calc_map_steps_i,CHAR_INFO_ACTIVE) = 0 : _continue ; 有効でなければ無視
			if char_info(sub_calc_map_steps_i,CHAR_INFO_DOWN) = 1 : _continue ; ダウンしていれば無視
			if ( char_mappos(sub_calc_map_steps_i,CIE_X) = sub_calc_map_steps_posx ) and ( char_mappos(sub_calc_map_steps_i,CIE_Y) = sub_calc_map_steps_posy ){
				; 自分は除外
			} else {
				; 侵入不可マスには -1 を入れる（map_steps）
				map_steps(char_mappos(sub_calc_map_steps_i,CIE_X),char_mappos(sub_calc_map_steps_i,CIE_Y)) = -1
			}
		next
	}

	getreq sub_calc_map_steps_record(3),SYSREQ_TIMER
	
	; 指定されたマスは 0 を入れる（map_steps）
	map_steps(sub_calc_map_steps_posx,sub_calc_map_steps_posy) = 0
	
	; 以下のfor文で指定した座標から各マスまで何マス移動すればたどり着くかを計算しmap_stepsに入れる（map_steps）
	for sub_calc_map_steps_i,1,(MAP_X-MAP_MERGIN)*(MAP_Y-MAP_MERGIN)
		count_blank = 0 ; -2のマスの数を数えておく
		; i を入れるのは現在は -2 で隣接マスに i-1 がある場合
		for sub_calc_map_steps_y,MAP_MERGIN,MAP_Y-MAP_MERGIN
			for sub_calc_map_steps_x,MAP_MERGIN,MAP_X-MAP_MERGIN
				if map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) = -2 {
					count_blank +=1
					if ( map_steps(sub_calc_map_steps_x-1,sub_calc_map_steps_y) = sub_calc_map_steps_i-1 ) or ( map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y-1) = sub_calc_map_steps_i-1 ) or ( map_steps(sub_calc_map_steps_x+1,sub_calc_map_steps_y) = sub_calc_map_steps_i-1 ) or ( map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y+1) = sub_calc_map_steps_i-1 ) {
						map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) = sub_calc_map_steps_i
					}
				}
			next
		next
		;if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: steps="+sub_calc_map_steps_i+"の時点で未計算マスはあと"+count_blank+"個"
		; -2のマスが1個も見つからなければ終了する
		if count_blank = 0 {
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: steps="+sub_calc_map_steps_i+"で処理終了"
			_break
		}
	next
	
	; 直後に移動可能なマスを格納する（map_steps_canmove）
	map_steps_canmove_cnt = 0
	dim map_steps_canmove,4
	if ( map_steps(sub_calc_map_steps_posx  ,sub_calc_map_steps_posy+1) = 1 ){
		map_steps_canmove(map_steps_canmove_cnt) = DIREC_DOWN
		map_steps_canmove_cnt += 1
	}
	if ( map_steps(sub_calc_map_steps_posx-1,sub_calc_map_steps_posy  ) = 1 ){
		map_steps_canmove(map_steps_canmove_cnt) = DIREC_LEFT
		map_steps_canmove_cnt += 1
	}
	if ( map_steps(sub_calc_map_steps_posx  ,sub_calc_map_steps_posy-1) = 1 ){
		map_steps_canmove(map_steps_canmove_cnt) = DIREC_UP
		map_steps_canmove_cnt += 1
	}
	if ( map_steps(sub_calc_map_steps_posx+1,sub_calc_map_steps_posy  ) = 1 ){
		map_steps_canmove(map_steps_canmove_cnt) = DIREC_RIGHT
		map_steps_canmove_cnt += 1
	}

	getreq sub_calc_map_steps_record(4),SYSREQ_TIMER

	; 指定座標にユニットがいれば追加情報を取得（map_steps_info）
	if sub_calc_map_steps_team >= 0 {
		for sub_calc_map_steps_i,0,CHAR_MAX
			if char_info(sub_calc_map_steps_i,CHAR_INFO_ACTIVE) = 1 {
				if char_info(sub_calc_map_steps_i,CHAR_INFO_DOWN) = 1 : _continue ; ダウンしていたら無視する
				if char_mappos(sub_calc_map_steps_i,CIE_X) = sub_calc_map_steps_posx and char_mappos(sub_calc_map_steps_i,CIE_Y) = sub_calc_map_steps_posy {
					; 自分の場合は何もしない
				}
				else{
					; 自チームの場合
					if char_info(sub_calc_map_steps_i,CHAR_INFO_TEAM) = sub_calc_map_steps_team {
						map_steps_info(char_mappos(sub_calc_map_steps_i,CIE_X),char_mappos(sub_calc_map_steps_i,CIE_Y)) += MAP_STEPS_INFO_ALLYUNIT
						if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: "+char_mappos(sub_calc_map_steps_i,CIE_X)+","+char_mappos(sub_calc_map_steps_i,CIE_Y)+"にMAP_STEPS_INFO_ALLYUNITを設定"
					}
					; 敵チームの場合
					if char_info(sub_calc_map_steps_i,CHAR_INFO_TEAM) ! sub_calc_map_steps_team {
						map_steps_info(char_mappos(sub_calc_map_steps_i,CIE_X),char_mappos(sub_calc_map_steps_i,CIE_Y)) += MAP_STEPS_INFO_ENEMYUNIT
						if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: "+char_mappos(sub_calc_map_steps_i,CIE_X)+","+char_mappos(sub_calc_map_steps_i,CIE_Y)+"にMAP_STEPS_INFO_ENEMYUNITを設定"
					}
				}
			}
		next
	} 

	getreq sub_calc_map_steps_record(5),SYSREQ_TIMER

	if sub_calc_map_steps_flag & 1 {
		; 最寄りで自分の色に塗られていない最短の向きが格納する
		map_steps_nocolormove_cnt = 0
		dim map_steps_nocolormove,4

		; 最寄りの MAP_STEPS_INFO_NOCOLOR か MAP_STEPS_INFO_ENEMYCOLOR を探す（これをtargetとする）
		dim sub_calc_map_steps_targetx,32
		dim sub_calc_map_steps_targety,32
		sub_calc_map_steps_targetc = 0
		sub_calc_map_steps_targetr = -1
		for sub_calc_map_steps_r,1,SEARCH_RANGE
			for sub_calc_map_steps_y,MAP_MERGIN,MAP_Y-MAP_MERGIN
				for sub_calc_map_steps_x,MAP_MERGIN,MAP_X-MAP_MERGIN
					if map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) ! sub_calc_map_steps_r : _continue
					if ( map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_NOCOLOR ) or ( map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_ENEMYCOLOR ) {
						if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: nocolormoveでターゲット特定 x="+sub_calc_map_steps_x+", y="+sub_calc_map_steps_y+", r="+sub_calc_map_steps_r
						sub_calc_map_steps_targetx(sub_calc_map_steps_targetc) = sub_calc_map_steps_x
						sub_calc_map_steps_targety(sub_calc_map_steps_targetc) = sub_calc_map_steps_y
						sub_calc_map_steps_targetc += 1
						sub_calc_map_steps_targetr = sub_calc_map_steps_r
					}
				next
			next
			; 候補があれば探索は終了
			if sub_calc_map_steps_targetc > 0 : _break
		next
	
		if ( sub_calc_map_steps_targetc > 0 ) {
			sub_calc_map_steps_scani = rnd(sub_calc_map_steps_targetc)
			; targetから最寄りの隣接しているstepsが1つ低いところを探し、そこに移動する。その際scanaには逆向きを入れておく
			; 最寄りの隣接が1以上なら同じ作業を繰り返す
			; 最寄りの隣接が0だった場合は、scanaの向きが steps=0 から steps=1 に移動できる向きになる
	
			sub_calc_map_steps_scanx = sub_calc_map_steps_targetx(sub_calc_map_steps_scani)
			sub_calc_map_steps_scany = sub_calc_map_steps_targety(sub_calc_map_steps_scani)
			sub_calc_map_steps_scanr = sub_calc_map_steps_targetr - 1
			sub_calc_map_steps_scana = DIREC_NONE
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: nocolormoveで検索開始 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
		
*sub_calc_map_steps_nocolormove
			
			if map_steps(sub_calc_map_steps_scanx+1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
				sub_calc_map_steps_scanx += 1
				sub_calc_map_steps_scanr -= 1
				sub_calc_map_steps_scana = DIREC_LEFT
			} else {
				if map_steps(sub_calc_map_steps_scanx-1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
					sub_calc_map_steps_scanx -= 1
					sub_calc_map_steps_scanr -= 1
					sub_calc_map_steps_scana = DIREC_RIGHT
				} else {
					if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany+1) = sub_calc_map_steps_scanr {
						sub_calc_map_steps_scany += 1
						sub_calc_map_steps_scanr -= 1
						sub_calc_map_steps_scana = DIREC_UP
					} else {
						if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany-1) = sub_calc_map_steps_scanr {
							sub_calc_map_steps_scany -= 1
							sub_calc_map_steps_scanr -= 1
							sub_calc_map_steps_scana = DIREC_DOWN
						} else {
							; もしrが1つも減らない場合、不具合で無限ループになるのでログを出して終了する
							if DEBUG_MODE : logmes "W exec *sub_calc_map_steps: nocolormoveで無限ループ sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
							; 次に備えて引数は初期化
							sub_calc_map_steps_posx = -1
							sub_calc_map_steps_posy = -1
							return
						}
					}
				}
			}
			
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: nocolormoveの途中経過 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			if sub_calc_map_steps_scanr >= 0 : goto *sub_calc_map_steps_nocolormove
		
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: nocolormoveは探索終了 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			map_steps_nocolormove(0) = sub_calc_map_steps_scana
			map_steps_nocolormove_cnt = 1
		}
	}

	getreq sub_calc_map_steps_record(6),SYSREQ_TIMER
	
	if sub_calc_map_steps_flag & 2 {
		; 最寄りの敵への最短の向きが格納する
		map_steps_enemymove_cnt = 0
		dim map_steps_enemymove,4
	
		; 最寄りの MAP_STEPS_INFO_ENEMYUNIT を探す（これをtargetとする）
		dim sub_calc_map_steps_targetx,32
		dim sub_calc_map_steps_targety,32
		sub_calc_map_steps_targetc = 0
		sub_calc_map_steps_targetr = -1
		for sub_calc_map_steps_r,1,SEARCH_RANGE
			for sub_calc_map_steps_y,MAP_MERGIN,MAP_Y-MAP_MERGIN
				for sub_calc_map_steps_x,MAP_MERGIN,MAP_X-MAP_MERGIN
					if map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) ! sub_calc_map_steps_r : _continue
					if map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_ENEMYUNIT {
						if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: enemymoveでターゲット特定 x="+sub_calc_map_steps_x+", y="+sub_calc_map_steps_y+", r="+sub_calc_map_steps_r
						sub_calc_map_steps_targetx(sub_calc_map_steps_targetc) = sub_calc_map_steps_x
						sub_calc_map_steps_targety(sub_calc_map_steps_targetc) = sub_calc_map_steps_y
						sub_calc_map_steps_targetc += 1
						sub_calc_map_steps_targetr = sub_calc_map_steps_r
					}
				next
			next
			; 候補があれば探索は終了
			if sub_calc_map_steps_targetc > 0 : _break
		next
	
		if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: enemymoveの探索準備 sub_calc_map_steps_targetc="+sub_calc_map_steps_targetc
		if ( sub_calc_map_steps_targetc > 0 ) {
			sub_calc_map_steps_scani = rnd(sub_calc_map_steps_targetc)
			; targetから最寄りの隣接しているstepsが1つ低いところを探し、そこに移動する。その際scanaには逆向きを入れておく
			; 最寄りの隣接が1以上なら同じ作業を繰り返す
			; 最寄りの隣接が0だった場合は、scanaの向きが steps=0 から steps=1 に移動できる向きになる
	
			sub_calc_map_steps_scanx = sub_calc_map_steps_targetx(sub_calc_map_steps_scani)
			sub_calc_map_steps_scany = sub_calc_map_steps_targety(sub_calc_map_steps_scani)
			sub_calc_map_steps_scanr = sub_calc_map_steps_targetr - 1
			sub_calc_map_steps_scana = DIREC_NONE
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: enemymoveで検索開始 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
		
*sub_calc_map_steps_enemymove
			
			if map_steps(sub_calc_map_steps_scanx+1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
				sub_calc_map_steps_scanx += 1
				sub_calc_map_steps_scanr -= 1
				sub_calc_map_steps_scana = DIREC_LEFT
			} else {
				if map_steps(sub_calc_map_steps_scanx-1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
					sub_calc_map_steps_scanx -= 1
					sub_calc_map_steps_scanr -= 1
					sub_calc_map_steps_scana = DIREC_RIGHT
				} else {
					if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany+1) = sub_calc_map_steps_scanr {
						sub_calc_map_steps_scany += 1
						sub_calc_map_steps_scanr -= 1
						sub_calc_map_steps_scana = DIREC_UP
					} else {
						if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany-1) = sub_calc_map_steps_scanr {
							sub_calc_map_steps_scany -= 1
							sub_calc_map_steps_scanr -= 1
							sub_calc_map_steps_scana = DIREC_DOWN
						} else {
							; もしrが1つも減らない場合、不具合で無限ループになるのでログを出して終了する
							if DEBUG_MODE : logmes "W exec *sub_calc_map_steps: enemymoveで無限ループ sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
							; 次に備えて引数は初期化
							sub_calc_map_steps_posx = -1
							sub_calc_map_steps_posy = -1
							sub_calc_map_steps_flag = -1
							return
						}
					}
				}
			}
			
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: enemymoveの途中経過 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			if sub_calc_map_steps_scanr >= 0 : goto *sub_calc_map_steps_enemymove
		
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: enemymoveは探索終了 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			map_steps_enemymove(0) = sub_calc_map_steps_scana
			map_steps_enemymove_cnt = 1
		}
	}

	getreq sub_calc_map_steps_record(7),SYSREQ_TIMER

	if sub_calc_map_steps_flag & 8 {
		; 最寄りで自分の色に塗られている最短の向きが格納する
		map_steps_allycolormove_cnt = 0
		dim map_steps_allycolormove,4

		; 最寄りの MAP_STEPS_INFO_ALLYCOLOR を探す（これをtargetとする）
		dim sub_calc_map_steps_targetx,32
		dim sub_calc_map_steps_targety,32
		sub_calc_map_steps_targetc = 0
		sub_calc_map_steps_targetr = -1
		for sub_calc_map_steps_r,1,SEARCH_RANGE
			for sub_calc_map_steps_y,MAP_MERGIN,MAP_Y-MAP_MERGIN
				for sub_calc_map_steps_x,MAP_MERGIN,MAP_X-MAP_MERGIN
					if map_steps(sub_calc_map_steps_x,sub_calc_map_steps_y) ! sub_calc_map_steps_r : _continue
					if ( map_steps_info(sub_calc_map_steps_x,sub_calc_map_steps_y) & MAP_STEPS_INFO_ALLYCOLOR ) {
						if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: allycolormoveでターゲット特定 x="+sub_calc_map_steps_x+", y="+sub_calc_map_steps_y+", r="+sub_calc_map_steps_r
						sub_calc_map_steps_targetx(sub_calc_map_steps_targetc) = sub_calc_map_steps_x
						sub_calc_map_steps_targety(sub_calc_map_steps_targetc) = sub_calc_map_steps_y
						sub_calc_map_steps_targetc += 1
						sub_calc_map_steps_targetr = sub_calc_map_steps_r
					}
				next
			next
			; 候補があれば探索は終了
			if sub_calc_map_steps_targetc > 0 : _break
		next
	
		if ( sub_calc_map_steps_targetc > 0 ) {
			sub_calc_map_steps_scani = rnd(sub_calc_map_steps_targetc)
			; targetから最寄りの隣接しているstepsが1つ低いところを探し、そこに移動する。その際scanaには逆向きを入れておく
			; 最寄りの隣接が1以上なら同じ作業を繰り返す
			; 最寄りの隣接が0だった場合は、scanaの向きが steps=0 から steps=1 に移動できる向きになる
	
			sub_calc_map_steps_scanx = sub_calc_map_steps_targetx(sub_calc_map_steps_scani)
			sub_calc_map_steps_scany = sub_calc_map_steps_targety(sub_calc_map_steps_scani)
			sub_calc_map_steps_scanr = sub_calc_map_steps_targetr - 1
			sub_calc_map_steps_scana = DIREC_NONE
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: allycolormoveで検索開始 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
		
*sub_calc_map_steps_allycolormove
			
			if map_steps(sub_calc_map_steps_scanx+1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
				sub_calc_map_steps_scanx += 1
				sub_calc_map_steps_scanr -= 1
				sub_calc_map_steps_scana = DIREC_LEFT
			} else {
				if map_steps(sub_calc_map_steps_scanx-1,sub_calc_map_steps_scany  ) = sub_calc_map_steps_scanr {
					sub_calc_map_steps_scanx -= 1
					sub_calc_map_steps_scanr -= 1
					sub_calc_map_steps_scana = DIREC_RIGHT
				} else {
					if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany+1) = sub_calc_map_steps_scanr {
						sub_calc_map_steps_scany += 1
						sub_calc_map_steps_scanr -= 1
						sub_calc_map_steps_scana = DIREC_UP
					} else {
						if map_steps(sub_calc_map_steps_scanx  ,sub_calc_map_steps_scany-1) = sub_calc_map_steps_scanr {
							sub_calc_map_steps_scany -= 1
							sub_calc_map_steps_scanr -= 1
							sub_calc_map_steps_scana = DIREC_DOWN
						} else {
							; もしrが1つも減らない場合、不具合で無限ループになるのでログを出して終了する
							if DEBUG_MODE : logmes "W exec *sub_calc_map_steps: allycolormoveで無限ループ sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr
							; 次に備えて引数は初期化
							sub_calc_map_steps_posx = -1
							sub_calc_map_steps_posy = -1
							return
						}
					}
				}
			}
			
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: allycolormoveの途中経過 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			if sub_calc_map_steps_scanr >= 0 : goto *sub_calc_map_steps_allycolormove
		
			if DEBUG_MODE : logmes "D exec *sub_calc_map_steps: allycolormoveは探索終了 sub_calc_map_steps_scanx="+sub_calc_map_steps_scanx+", sub_calc_map_steps_scany="+sub_calc_map_steps_scany+", sub_calc_map_steps_scanr="+sub_calc_map_steps_scanr+", sub_calc_map_steps_scana="+sub_calc_map_steps_scana
			map_steps_allycolormove(0) = sub_calc_map_steps_scana
			map_steps_allycolormove_cnt = 1
		}
	}

	getreq sub_calc_map_steps_record(8),SYSREQ_TIMER


	; 処理時間の計算
	for sub_calc_map_steps_i,0,9-1
		sub_calc_map_steps_rangetime(sub_calc_map_steps_i) = sub_calc_map_steps_record(sub_calc_map_steps_i+1) - sub_calc_map_steps_record(sub_calc_map_steps_i)
	next
	sub_calc_map_steps_globalrangetime = sub_calc_map_steps_record(7) - sub_calc_map_steps_record(0)
	
	; 処理時間のロギング
	for sub_calc_map_steps_i,0,9-1
		if DEBUG_MODE : logmes strf("D exec *sub_calc_map_steps: %s: %3d",sub_calc_map_steps_rangetitle(sub_calc_map_steps_i),sub_calc_map_steps_rangetime(sub_calc_map_steps_i) )
	next

	
	if DEBUG_MODE : logmes "I exec *sub_calc_map_steps: map_steps関連情報を正常に取得しました x="+sub_calc_map_steps_posx+", y="+sub_calc_map_steps_posy+", flag="+sub_calc_map_steps_flag+" time="+sub_calc_map_steps_globalrangetime
	
	; 次に備えて引数は初期化
	sub_calc_map_steps_posx = -1
	sub_calc_map_steps_posy = -1
	sub_calc_map_steps_flag = -1
	return
	


	;---------------------------------------------------------------------------------
	; キャラIDの情報にキャラクタ定義IDの情報を入れる
	;   引数: sub_load_defchar_defcharid キャラクタ定義ID
	;   引数: sub_load_defchar_charid キャラID
	;---------------------------------------------------------------------------------
*sub_load_defchar
	if DEBUG_MODE : logmes "I call *sub_load_defchar: defcharid="+sub_load_defchar_defcharid+", charid="+sub_load_defchar_charid
	if ( sub_load_defchar_defcharid < 0 ) or ( sub_load_defchar_charid < 0 ) {
		if DEBUG_MODE : logmes "W exec *sub_load_defchar: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_load_defchar_defcharid = -1
		sub_load_defchar_charid = -1
		return
	}

	; スプライトの生成
	es_set SP_MAP+sub_load_defchar_charid,0,0,defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_ANIME_DOWN),0,5
	es_set SP_STATUS+sub_load_defchar_charid,0,0,defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_STATIC),0,5
	char_spid(sub_load_defchar_charid,CHAR_SPID_MAP) = SP_MAP+sub_load_defchar_charid
	char_spid(sub_load_defchar_charid,CHAR_SPID_STATUS) = SP_STATUS+sub_load_defchar_charid
	if DEBUG_MODE : logmes "D exec *sub_load_defchar: char_spid=["+char_spid(sub_load_defchar_charid,0)+","+char_spid(sub_load_defchar_charid,1)+"]"

	char_spcharid(sub_load_defchar_charid,DIREC_DOWN)  = defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_ANIME_DOWN)
	char_spcharid(sub_load_defchar_charid,DIREC_LEFT)  = defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_ANIME_LEFT)
	char_spcharid(sub_load_defchar_charid,DIREC_UP)    = defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_ANIME_UP)
	char_spcharid(sub_load_defchar_charid,DIREC_RIGHT) = defchar_sp(sub_load_defchar_defcharid,DEFCHAR_SP_ANIME_RIGHT)
	
	char_desc(sub_load_defchar_charid,0) = defchar_desc(sub_load_defchar_defcharid,0)
	char_info(sub_load_defchar_charid,CHAR_INFO_ACTIVE) = 1	; 有効
	char_info(sub_load_defchar_charid,CHAR_INFO_MOVEFREQ) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_MOVEFREQ)
	char_info(sub_load_defchar_charid,CHAR_INFO_MOVEFREQ_B) = char_info(sub_load_defchar_charid,CHAR_INFO_MOVEFREQ)
	char_info(sub_load_defchar_charid,CHAR_INFO_MAXHP) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_MAXHP)
	char_info(sub_load_defchar_charid,CHAR_INFO_MAXHP_B) = char_info(sub_load_defchar_charid,CHAR_INFO_MAXHP)
	char_info(sub_load_defchar_charid,CHAR_INFO_MAXWP) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_MAXWP)
	char_info(sub_load_defchar_charid,CHAR_INFO_MAXWP_B) = char_info(sub_load_defchar_charid,CHAR_INFO_MAXWP)
	char_info(sub_load_defchar_charid,CHAR_INFO_DEF) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_DEF)
	char_info(sub_load_defchar_charid,CHAR_INFO_DEF_B) = char_info(sub_load_defchar_charid,CHAR_INFO_DEF)
	char_info(sub_load_defchar_charid,CHAR_INFO_RESPAWN) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_RESPAWN)
	char_info(sub_load_defchar_charid,CHAR_INFO_RESPAWN_B) = char_info(sub_load_defchar_charid,CHAR_INFO_RESPAWN)
	char_info(sub_load_defchar_charid,CHAR_INFO_DOWNTIME) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_DOWNTIME)
	char_info(sub_load_defchar_charid,CHAR_INFO_DOWNTIME_B) = char_info(sub_load_defchar_charid,CHAR_INFO_DOWNTIME)
	char_info(sub_load_defchar_charid,CHAR_INFO_RESPAWNWEAPON) = 3	; 拠点防衛砲
	char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON1) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_WEAPON1)
	if char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON1) >= 0 { ; 武器がある場合は使用モードは色が塗れるなら塗るで初期化
		char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON1MODE) = CHAR_WEAPONMODE_PAINTER
	}
	char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON2) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_WEAPON2)
	if char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON2) >= 0 { ; 武器がある場合は使用モードは直ぐ使うで初期化
		char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON2MODE) = CHAR_WEAPONMODE_IMMEDIATELY
	}
	char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON3) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_WEAPON3)
	if char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON3) >= 0 { ; 武器がある場合は使用モードは直ぐ使うで初期化
		char_info(sub_load_defchar_charid,CHAR_INFO_WEAPON3MODE) = CHAR_WEAPONMODE_IMMEDIATELY
	}
	char_info(sub_load_defchar_charid,CHAR_INFO_WEAPONFA) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_WEAPONFA)

	; パッシブスキルの取り込み
	dim sub_load_defchar_passive,3
	sub_load_defchar_passive(0) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_PASSIVE1)
	sub_load_defchar_passive(1) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_PASSIVE2)
	sub_load_defchar_passive(2) = defchar_info(sub_load_defchar_defcharid,DEFCHAR_INFO_PASSIVE3)
	for sub_load_defchar_i,0,3
		if DEBUG_MODE : logmes strf("D in *sub_load_defchar, defcharid=%d i=%d passiveid=%d",sub_load_defchar_defcharid,sub_load_defchar_i,sub_load_defchar_passive(sub_load_defchar_i))
		if sub_load_defchar_passive(sub_load_defchar_i) <= 0 : _continue	; 1以上のみが設定ありのため0以下はスキップ
		if DEBUG_MODE : logmes strf("D in *sub_load_defchar, passive_flag=%d",passive_info(sub_load_defchar_passive(sub_load_defchar_i),PASSIVE_INFO_FLAG))
		if passive_info(sub_load_defchar_passive(sub_load_defchar_i),PASSIVE_INFO_FLAG) = PASSIVE_FLAG_FABUFF {
			char_info(sub_load_defchar_charid,CHAR_INFO_PASSIVE_FABUFF) = sub_load_defchar_passive(sub_load_defchar_i)
		}
		if passive_info(sub_load_defchar_passive(sub_load_defchar_i),PASSIVE_INFO_FLAG) = PASSIVE_FLAG_HALFHPSTATE {
			char_info(sub_load_defchar_charid,CHAR_INFO_PASSIVE_HALFHPSTATE) = sub_load_defchar_passive(sub_load_defchar_i)
		}
		if passive_info(sub_load_defchar_passive(sub_load_defchar_i),PASSIVE_INFO_FLAG) = PASSIVE_FLAG_ATCADDSTATE {
			char_info(sub_load_defchar_charid,CHAR_INFO_PASSIVE_ATCADDSTATE) = sub_load_defchar_passive(sub_load_defchar_i)
		}
		if passive_info(sub_load_defchar_passive(sub_load_defchar_i),PASSIVE_INFO_FLAG) = PASSIVE_FLAG_STATEADDUP {
			char_info(sub_load_defchar_charid,CHAR_INFO_PASSIVE_STATEADDUP) = sub_load_defchar_passive(sub_load_defchar_i)
		}
	next

	; 次に備えて引数は初期化
	sub_load_defchar_defcharid = -1
	sub_load_defchar_charid = -1
	return


	;---------------------------------------------------------------------------------
	; 記録をファイルに出力する
	;---------------------------------------------------------------------------------
*sub_save_record
	bsave "record_v2.txt",record_info
	return

	;---------------------------------------------------------------------------------
	; 記録をファイルに読み込む
	;---------------------------------------------------------------------------------
*sub_load_record
	exist "record_v2.txt"
	if strsize >= 0 {
		bload "record_v2.txt",record_info
	}
	else {
		; 古いバージョンの記録ファイルしかない場合
		exist "record.txt"
		if strsize >= 0 {
			bload "record.txt",record_info_v1
			for sub_load_record_i,0,RECORD_V1_MAX
				if record_info_v1(sub_load_record_i,RECORD_INFO_SCORE) > 0 {
					for sub_load_record_j,0,RECORD_INFO_V1_MAX
						record_info(sub_load_record_i,sub_load_record_j) = record_info_v1(sub_load_record_i,sub_load_record_j)
						record_info(sub_load_record_i,RECORD_INFO_SELECTPLAYER) = 0
						record_info(sub_load_record_i,RECORD_INFO_STEGESET) = 1
					next
				}
			next
		} else {
			; ファイルがない場合
			; 作者の記録をとりあえず書き込んでおく
			record_info(0,RECORD_INFO_SCORE) = 245316
			record_info(0,RECORD_INFO_LEVEL) = 10
			record_info(0,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
			record_info(0,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
			record_info(0,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
			record_info(0,RECORD_INFO_SELECTPLAYER) = 0
			record_info(0,RECORD_INFO_STEGESET) = 1
			record_info(1,RECORD_INFO_SCORE) = 65124
			record_info(1,RECORD_INFO_LEVEL) = 0
			record_info(1,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
			record_info(1,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
			record_info(1,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
			record_info(1,RECORD_INFO_SELECTPLAYER) = 0
			record_info(1,RECORD_INFO_STEGESET) = 1
			record_info(2,RECORD_INFO_SCORE) = 2849
			record_info(2,RECORD_INFO_LEVEL) = -19
			record_info(2,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
			record_info(2,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
			record_info(2,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
			record_info(2,RECORD_INFO_SELECTPLAYER) = 0
			record_info(2,RECORD_INFO_STEGESET) = 1
			record_info(3,RECORD_INFO_SCORE) = 235128
			record_info(3,RECORD_INFO_LEVEL) = 10
			record_info(3,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
			record_info(3,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
			record_info(3,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
			record_info(3,RECORD_INFO_SELECTPLAYER) = 0
			record_info(3,RECORD_INFO_STEGESET) = 2
			record_info(4,RECORD_INFO_SCORE) = 63684
			record_info(4,RECORD_INFO_LEVEL) = 0
			record_info(4,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
			record_info(4,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
			record_info(4,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
			record_info(4,RECORD_INFO_SELECTPLAYER) = 0
			record_info(4,RECORD_INFO_STEGESET) = 2

		}
	}
	return

	;---------------------------------------------------------------------------------
	; 記録を追加する
	;---------------------------------------------------------------------------------
*sub_add_record
	sub_add_record_target = -1
	for sub_add_record_i,0,RECORD_MAX
		; 点数が低ければそこに挿入、高ければ次へ進む
		if DEBUG_MODE : logmes strf("D exec *sub_add_record %d vs %d",record_info(sub_add_record_i,RECORD_INFO_SCORE),game_info(GAME_INFO_SCORE))
		if record_info(sub_add_record_i,RECORD_INFO_SCORE) > game_info(GAME_INFO_SCORE) : _continue

		sub_add_record_target = sub_add_record_i
		if DEBUG_MODE : logmes strf("D exec *sub_add_record set target %d",sub_add_record_target)
		_break
	next

	if DEBUG_MODE : logmes "D exec *sub_add_record target="+sub_add_record_target
	if sub_add_record_target = -1 : return ; ランキング外のため何もしない
	
	; targetより後ろのデータを繰り下げる
	for sub_add_record_i,RECORD_MAX-1,sub_add_record_target,-1
		record_info(sub_add_record_i,RECORD_INFO_SCORE) = record_info(sub_add_record_i-1,RECORD_INFO_SCORE)
		record_info(sub_add_record_i,RECORD_INFO_LEVEL) = record_info(sub_add_record_i-1,RECORD_INFO_LEVEL)
		record_info(sub_add_record_i,RECORD_INFO_VER_MAJOR) = record_info(sub_add_record_i-1,RECORD_INFO_VER_MAJOR)
		record_info(sub_add_record_i,RECORD_INFO_VER_MINOR) = record_info(sub_add_record_i-1,RECORD_INFO_VER_MINOR)
		record_info(sub_add_record_i,RECORD_INFO_VER_PATCH) = record_info(sub_add_record_i-1,RECORD_INFO_VER_PATCH)
		record_info(sub_add_record_i,RECORD_INFO_SELECTPLAYER) = record_info(sub_add_record_i-1,RECORD_INFO_SELECTPLAYER)
		record_info(sub_add_record_i,RECORD_INFO_STEGESET) = record_info(sub_add_record_i-1,RECORD_INFO_STEGESET)
		if DEBUG_MODE : logmes "D exec *sub_add_record copy from="+(sub_add_record_i-1)+" to="+sub_add_record_i
	next

	record_info(sub_add_record_target,RECORD_INFO_SCORE) = game_info(GAME_INFO_SCORE)
	record_info(sub_add_record_target,RECORD_INFO_LEVEL) = game_info(GAME_INFO_TOTALLEVEL)
	record_info(sub_add_record_target,RECORD_INFO_VER_MAJOR) = GAME_VERSION_MAJOR
	record_info(sub_add_record_target,RECORD_INFO_VER_MINOR) = GAME_VERSION_MINOR
	record_info(sub_add_record_target,RECORD_INFO_VER_PATCH) = GAME_VERSION_PATCH
	record_info(sub_add_record_target,RECORD_INFO_SELECTPLAYER) = game_info(GAME_INFO_SELECTPLAYER)
	record_info(sub_add_record_target,RECORD_INFO_STEGESET) = game_info(GAME_INFO_SELECTSTEGESET)
						
	gosub *sub_save_record
	return


	;---------------------------------------------------------------------------------
	; 空いているところにバフをセットする
	;   引数: sub_set_buff_charid   キャラクタID
	;   引数: sub_set_buff_resttime バフの効果時間
	;   引数: sub_set_buff_type     バフのタイプ
	;   引数: sub_set_buff_value    バフの効果量
	;---------------------------------------------------------------------------------
*sub_set_buff
	logmes "I call *sub_set_buff: charid="+sub_set_buff_charid+", buff_type="+sub_set_buff_type
	if ( sub_set_buff_charid < 0 ) or ( sub_set_buff_resttime < 0 ) or ( sub_set_buff_type < 0 ) {
		logmes "W exec *sub_set_buff: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_set_buff_charid = -1
		sub_set_buff_resttime = -1
		sub_set_buff_type = BUFF_TYPE_NONE
		sub_set_buff_value = 0
		return
	}

	for sub_set_buff_i,0,BUFF_STACK_MAX
		sub_set_buff_buffindex_active   = CHAR_INFO_BUFF_BEGIN+sub_set_buff_i*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_ACTIVE
		sub_set_buff_buffindex_resttime = CHAR_INFO_BUFF_BEGIN+sub_set_buff_i*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_RESTTIME
		sub_set_buff_buffindex_type     = CHAR_INFO_BUFF_BEGIN+sub_set_buff_i*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_TYPE
		sub_set_buff_buffindex_value    = CHAR_INFO_BUFF_BEGIN+sub_set_buff_i*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_VALUE

		if char_info(sub_set_buff_charid,sub_set_buff_buffindex_type) = BUFF_TYPE_NONE {	; 空いていることを確認
			logmes strf("D exec *sub_set_buff: set buff stackid=%d",sub_set_buff_i)
			char_info(sub_set_buff_charid,sub_set_buff_buffindex_type)     = sub_set_buff_type
			char_info(sub_set_buff_charid,sub_set_buff_buffindex_resttime) = sub_set_buff_resttime
			char_info(sub_set_buff_charid,sub_set_buff_buffindex_value)    = sub_set_buff_value
			_break
		}
		if sub_set_buff_i = BUFF_STACK_MAX -1 {
			logmes "W exec *sub_set_buff: 空きがなくバフがセットできません"
		}
	next

	; 次に備えて引数は初期化
	sub_set_buff_charid = -1
	sub_set_buff_resttime = -1
	sub_set_buff_type = BUFF_TYPE_NONE
	sub_set_buff_value = 0
	return


	;---------------------------------------------------------------------------------
	; 空いているところにステートをセットする
	;   引数: sub_set_state_charid   キャラクタID
	;   引数: sub_set_state_resttime ステートの効果時間
	;   引数: sub_set_state_type     ステートのタイプ
	;---------------------------------------------------------------------------------
*sub_set_state
	if DEBUG_MODE : logmes "I call *sub_set_state: charid="+sub_set_state_charid+", state_type="+sub_set_state_type
	if ( sub_set_state_charid < 0 ) or ( sub_set_state_resttime < 0 ) or ( sub_set_state_type < 0 ) {
		if DEBUG_MODE : logmes "W exec *sub_set_state: 引数が正しくありません"
		; 引数が正しくないので処理しない
		; 次に備えて引数は初期化
		sub_set_state_charid = -1
		sub_set_state_resttime = -1
		sub_set_state_type = STATE_TYPE_NONE
		return
	}

	for sub_set_state_i,0,STATE_STACK_MAX
		sub_set_state_index_active   = CHAR_INFO_STATE_BEGIN+sub_set_state_i*STATE_STACK_INFO_MAX+STATE_STACK_INFO_ACTIVE
		sub_set_state_index_resttime = CHAR_INFO_STATE_BEGIN+sub_set_state_i*STATE_STACK_INFO_MAX+STATE_STACK_INFO_RESTTIME
		sub_set_state_index_type     = CHAR_INFO_STATE_BEGIN+sub_set_state_i*STATE_STACK_INFO_MAX+STATE_STACK_INFO_TYPE
		sub_set_state_index_spid     = CHAR_INFO_STATE_BEGIN+sub_set_state_i*STATE_STACK_INFO_MAX+STATE_STACK_INFO_SPID
		if DEBUG_MODE : logmes "D exec *sub_set_state: i="+sub_set_state_i+", index_type="+sub_set_state_index_type+", type="+char_info(sub_set_state_charid,sub_set_state_index_type)
		if char_info(sub_set_state_charid,sub_set_state_index_type) = STATE_TYPE_NONE {	; 空いていることを確認
			if DEBUG_MODE : logmes "D exec *sub_set_state: i="+sub_set_state_i+"にステートをセット"
			char_info(sub_set_state_charid,sub_set_state_index_active)   = 0
			char_info(sub_set_state_charid,sub_set_state_index_type)     = sub_set_state_type
			char_info(sub_set_state_charid,sub_set_state_index_resttime) = sub_set_state_resttime
			_break
		}
		if sub_set_state_i = STATE_STACK_MAX -1 {
			logmes "W exec *sub_set_state: 空きがなくステートがセットできません"
		}
	next

	; 次に備えて引数は初期化
	sub_set_state_charid = -1
	sub_set_state_resttime = -1
	sub_set_state_type = STATE_TYPE_NONE
	return


	;---------------------------------------------------------------------------------
	; ダメージアイコンを表示する
	;   引数: sub_show_damage_value 数字（マイナスを赤、プラスを青で表示）
	;   引数: sub_show_damage_x     起点となるx座標(px座標系)
	;   引数: sub_show_damage_y     起点となるy座標(px座標系)
	;---------------------------------------------------------------------------------
*sub_show_damage
	; マイナスを赤、プラスを青
	if sub_show_damage_value < 0{
		sub_show_damage_offset = SPCHAR_RNUMBER_STATIC
		sub_show_damage_v = sub_show_damage_value * -1
	} else {
		sub_show_damage_offset = SPCHAR_BNUMBER_STATIC
		sub_show_damage_v = sub_show_damage_value
	}
	
	; 100の位、10の位、1の位に分割
	dim sub_show_damage_n,3
	sub_show_damage_n(0) = sub_show_damage_v / 100 \ 10
	sub_show_damage_n(1) = sub_show_damage_v / 10 \ 10
	sub_show_damage_n(2) = sub_show_damage_v \ 10

	sub_show_damage_display = 0
	dim sub_show_damage_sp,3
	for sub_show_damage_i,0,3
		if sub_show_damage_n(sub_show_damage_i) > 0 : sub_show_damage_display = 1
		if sub_show_damage_display = 1 {
			; 空きスプライトIDを検索
			es_exnew sub_show_damage_sp(sub_show_damage_i),SP_NUMBER_STATIC,-1
			; スプライトを生成
			es_set sub_show_damage_sp(sub_show_damage_i),sub_show_damage_x+16*sub_show_damage_i-16,sub_show_damage_y,sub_show_damage_offset+sub_show_damage_n(sub_show_damage_i),0,1
			; スプライトを移動
			if sub_show_damage_x < WINDOW_X-70 {
				es_adir sub_show_damage_sp(sub_show_damage_i),135,300
			} else {
				es_adir sub_show_damage_sp(sub_show_damage_i),225,300
			}
			es_flag sub_show_damage_sp(sub_show_damage_i),$400
			es_gravity sub_show_damage_sp(sub_show_damage_i),0,64
			; スプライトを自動で消滅
			es_fade sub_show_damage_sp(sub_show_damage_i),ESSPF_TIMEWIPE,20
		}
	next

	; 次に備えて引数は初期化	
	sub_show_damage_value=0
	sub_show_damage_x=-1
	sub_show_damage_y=-1
	return


	;---------------------------------------------------------------------------------
	; バフの効果量を再計算
	;---------------------------------------------------------------------------------	
*sub_recal_value
	logmes "I call *sub_recal_value"
	for sub_recal_value_i,0,CHAR_MAX
		for sub_recal_value_j,0,BUFF_TYPE_MAX
			char_info(sub_recal_value_i,CHAR_INFO_BUFFVALUE_BEGIN+sub_recal_value_j) = 0
		next
		for sub_recal_value_j,0,BUFF_STACK_MAX
			sub_recal_value_buffindex_resttime = CHAR_INFO_BUFF_BEGIN+sub_recal_value_j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_RESTTIME
			sub_recal_value_buffindex_type     = CHAR_INFO_BUFF_BEGIN+sub_recal_value_j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_TYPE
			sub_recal_value_buffindex_value    = CHAR_INFO_BUFF_BEGIN+sub_recal_value_j*BUFF_STACK_INFO_MAX+BUFF_STACK_INFO_VALUE
			
			sub_recal_value_buff_resttime = char_info(sub_recal_value_i,sub_recal_value_buffindex_resttime)
			sub_recal_value_buff_type     = char_info(sub_recal_value_i,sub_recal_value_buffindex_type)
			sub_recal_value_buff_value    = char_info(sub_recal_value_i,sub_recal_value_buffindex_value)
			if sub_recal_value_buff_type > 0 {
				if sub_recal_value_buff_resttime > 0 {
					char_info(sub_recal_value_i,CHAR_INFO_BUFFVALUE_BEGIN+sub_recal_value_buff_type) += sub_recal_value_buff_value	; バフの効果量に加算
					logmes strf("exec *sub_recal_value: char_info(%d,%d) += %d",sub_recal_value_i,CHAR_INFO_BUFFVALUE_BEGIN+sub_recal_value_buff_type,sub_recal_value_buff_value)
				}
			}
		next
		if sub_recal_value_i = 0 {
			logmes strf("exec *sub_recal_value: メイドメイ ATCバフ=%d",char_info(0,CHAR_INFO_BUFFVALUE_ATC))
		}
		; バフ効果量を反映
		for sub_recal_value_j,0,BUFF_TYPE_MAX
			sub_recal_value_buff_value = char_info(sub_recal_value_i,CHAR_INFO_BUFFVALUE_BEGIN+sub_recal_value_j)
			if sub_recal_value_j = BUFF_TYPE_MOVE {		; 移動速度 = 基本値 x 2 / ( value /100 +2 )
										; value -100: 200%, 0: 100%, 100: 67%, 200, 50%
				if sub_recal_value_buff_value < -100 : sub_recal_value_buff_value = -100	; -100未満は-100に修正
				char_info(sub_recal_value_i,CHAR_INFO_MOVEFREQ_B) = char_info(sub_recal_value_i,CHAR_INFO_MOVEFREQ) * 2 / ( sub_recal_value_buff_value / 100 + 2 )
			}
			if sub_recal_value_j = BUFF_TYPE_MAXHP {	; 最大HP = 基本値 x ( 100 + value ) /100
				if sub_recal_value_buff_value < -100 : sub_recal_value_buff_value = -100	; -100未満は-100に修正
				char_info(sub_recal_value_i,CHAR_INFO_MAXHP_B) = char_info(sub_recal_value_i,CHAR_INFO_MAXHP) * ( 100 + sub_recal_value_buff_value ) / 100
				if char_info(sub_recal_value_i,CHAR_INFO_MAXHP_B) < 1 : char_info(sub_recal_value_i,CHAR_INFO_MAXHP_B) = 1	; 最低でも1を保証
			}
			if sub_recal_value_j = BUFF_TYPE_MAXWP {	; 最大WP = 基本値 x ( 100 + value ) /100
				if sub_recal_value_buff_value < -100 : sub_recal_value_buff_value = -100	; -100未満は-100に修正
				char_info(sub_recal_value_i,CHAR_INFO_MAXWP_B) = char_info(sub_recal_value_i,CHAR_INFO_MAXWP) * ( 100 + sub_recal_value_buff_value ) / 100
				if char_info(sub_recal_value_i,CHAR_INFO_MAXWP_B) < 10 : char_info(sub_recal_value_i,CHAR_INFO_MAXWP_B) = 10	; 最低でも10を保証
			}
			if sub_recal_value_j = BUFF_TYPE_DEF {		; 防御力 = 基本値 + value
				char_info(sub_recal_value_i,CHAR_INFO_DEF_B) = char_info(sub_recal_value_i,CHAR_INFO_DEF) + sub_recal_value_buff_value
				if char_info(sub_recal_value_i,CHAR_INFO_DEF_B) < 0 : char_info(sub_recal_value_i,CHAR_INFO_DEF_B) = 0	; 最低でも0を保証
			}
			if sub_recal_value_j = BUFF_TYPE_RESPAWN {		; リスポーン回数 = 基本値 + value　※一時的にはならず常に永続効果となる
				char_info(sub_recal_value_i,CHAR_INFO_RESPAWN_B) = char_info(sub_recal_value_i,CHAR_INFO_RESPAWN) + sub_recal_value_buff_value
				if char_info(sub_recal_value_i,CHAR_INFO_RESPAWN_B) < 0 : char_info(sub_recal_value_i,CHAR_INFO_RESPAWN_B) = 0	; 最低でも0を保証
				; CHAR_INFO_RESPAWNから残りリスポーン回数は*reset_varsでしか反映されないので、変動分はここで直接更新する
				char_info(sub_recal_value_i,CHAR_INFO_RESTRESPAWN) += sub_recal_value_buff_value
			}
			if sub_recal_value_j = BUFF_TYPE_DOWNTIME {	; ダウンタイム = 基本値 x 4 / ( value /100 +4 )
										; value -300: 400%, 0: 100%, 100: 80%, 200, 67%, 400, 50%
				if sub_recal_value_buff_value < -300 : sub_recal_value_buff_value = -300	; -300未満は-300に修正
				char_info(sub_recal_value_i,CHAR_INFO_DOWNTIME_B) = char_info(sub_recal_value_i,CHAR_INFO_DOWNTIME) * 4 / ( sub_recal_value_buff_value / 100 + 4 )
				if char_info(sub_recal_value_i,CHAR_INFO_DOWNTIME_B) < 30 : char_info(sub_recal_value_i,CHAR_INFO_DOWNTIME_B) = 30	; 最低でも30を保証（消滅のアニメーション分）
			}
			; 以下は弾丸生成時に反映するため、ここでは処理しない
			; 攻撃力 = 基本値 x ( 100 + value ) /100
			if sub_recal_value_j = BUFF_TYPE_ATC {	
				logmes strf("exec *sub_recal_value: ATC charid=%d buff_value=%d",sub_recal_value_i,sub_recal_value_buff_value)
			}
			; 色蓄積力 = 基本値 x ( 100 + value ) /100
			; 消費WP = 基本値 x ( 100 - value ) /100
			; 射程 = 基本値 + value
			; 拡散範囲 = 基本値 + value
			; 減衰率 = 基本値 + value
			; 再装填速度 = 基本値 x ( 100 - value ) /100
		next
	next
	return

*end_sub_hsp

